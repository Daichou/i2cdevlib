// I2Cdev library collection - MPU6050 I2C device class		// I2Cdev library collection - MPU6050 I2C device class
// Based on InvenSense MPU-6050 register map document rev. 2.	// Based on InvenSense MPU-6050 register map document rev. 2.
// 8/24/2011 by Jeff Rowberg <jeff@rowberg.net>			// 8/24/2011 by Jeff Rowberg <jeff@rowberg.net>
// 11/28/2014 by Marton Sebok <sebokmarton@gmail.com>		// 11/28/2014 by Marton Sebok <sebokmarton@gmail.com>
//								//
// Updates should (hopefully) always be available at https://	// Updates should (hopefully) always be available at https://
//								//
// Changelog:							// Changelog:
//     ...        - ongoing debug release			//     ...        - ongoing debug release
//     2014-11-28 - ported to PIC18 peripheral library from A	//     2014-11-28 - ported to PIC18 peripheral library from A

// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS 	// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS 
// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. 	// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. 
// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.		// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.

/* ============================================			/* ============================================
I2Cdev device library code is placed under the MIT license	I2Cdev device library code is placed under the MIT license
Copyright (c) 2012 Jeff Rowberg					Copyright (c) 2012 Jeff Rowberg
Copyright (c) 2014 Marton Sebok					Copyright (c) 2014 Marton Sebok

Permission is hereby granted, free of charge, to any person o	Permission is hereby granted, free of charge, to any person o
of this software and associated documentation files (the "Sof	of this software and associated documentation files (the "Sof
in the Software without restriction, including without limita	in the Software without restriction, including without limita
to use, copy, modify, merge, publish, distribute, sublicense,	to use, copy, modify, merge, publish, distribute, sublicense,
copies of the Software, and to permit persons to whom the Sof	copies of the Software, and to permit persons to whom the Sof
furnished to do so, subject to the following conditions:	furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall b	The above copyright notice and this permission notice shall b
all copies or substantial portions of the Software.		all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIN	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIN
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCH	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCH
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO E	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO E
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWIS	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWIS
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
THE SOFTWARE.							THE SOFTWARE.
===============================================			===============================================
*/								*/

#include "MPU6050.h"						#include "MPU6050.h"

MPU6050_t mpu6050;						MPU6050_t mpu6050;

/** Specific address constructor.				/** Specific address constructor.
 * @param address I2C address					 * @param address I2C address
 * @see MPU6050_DEFAULT_ADDRESS					 * @see MPU6050_DEFAULT_ADDRESS
 * @see MPU6050_ADDRESS_AD0_LOW					 * @see MPU6050_ADDRESS_AD0_LOW
 * @see MPU6050_ADDRESS_AD0_HIGH				 * @see MPU6050_ADDRESS_AD0_HIGH
 */								 */
void MPU6050(uint8_t address)				      |	void MPU6050(uint8_t address) {
{							      |	    mpu6050.devAddr = address;
	mpu6050.devAddr = address;			      <
}								}

/** Power on and prepare for general usage.			/** Power on and prepare for general usage.
 * This will activate the device and take it out of sleep mod	 * This will activate the device and take it out of sleep mod
 * after start-up). This function also sets both the accelero	 * after start-up). This function also sets both the accelero
 * to their most sensitive settings, namely +/- 2g and +/- 25	 * to their most sensitive settings, namely +/- 2g and +/- 25
 * the clock source to use the X Gyro for reference, which is	 * the clock source to use the X Gyro for reference, which is
 * the default internal clock source.				 * the default internal clock source.
 */								 */
void MPU6050_initialize()				      |	void MPU6050_initialize() {
{							      <
    MPU6050_setClockSource(MPU6050_CLOCK_PLL_XGYRO);		    MPU6050_setClockSource(MPU6050_CLOCK_PLL_XGYRO);
    MPU6050_setFullScaleGyroRange(MPU6050_GYRO_FS_250);		    MPU6050_setFullScaleGyroRange(MPU6050_GYRO_FS_250);
    MPU6050_setFullScaleAccelRange(MPU6050_ACCEL_FS_2);		    MPU6050_setFullScaleAccelRange(MPU6050_ACCEL_FS_2);
    MPU6050_setSleepEnabled(false);			      |	    MPU6050_setSleepEnabled(false); // thanks to Jack Elston 
}								}

/** Verify the I2C connection.					/** Verify the I2C connection.
 * Make sure the device is connected and responds as expected	 * Make sure the device is connected and responds as expected
 * @return True if connection is valid, false otherwise		 * @return True if connection is valid, false otherwise
 */								 */
bool MPU6050_testConnection()				      |	bool MPU6050_testConnection() {
{							      |	    return MPU6050_getDeviceID() == 0x34;
	return MPU6050_getDeviceID() == 0x34;		      <
}								}

// AUX_VDDIO register (InvenSense demo code calls this RA_*G_	// AUX_VDDIO register (InvenSense demo code calls this RA_*G_

/** Get the auxiliary I2C supply voltage level.			/** Get the auxiliary I2C supply voltage level.
 * When set to 1, the auxiliary I2C bus high logic level is V	 * When set to 1, the auxiliary I2C bus high logic level is V
 * 0, the auxiliary I2C bus high logic level is VLOGIC. This 	 * 0, the auxiliary I2C bus high logic level is VLOGIC. This 
 * the MPU-6000, which does not have a VLOGIC pin.		 * the MPU-6000, which does not have a VLOGIC pin.
 * @return I2C supply voltage level (0=VLOGIC, 1=VDD)		 * @return I2C supply voltage level (0=VLOGIC, 1=VDD)
 */								 */
uint8_t MPU6050_getAuxVDDIOLevel()			      |	uint8_t MPU6050_getAuxVDDIOLevel() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_YG_OFFS_TC, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_YG_OFFS_TC |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set the auxiliary I2C supply voltage level.			/** Set the auxiliary I2C supply voltage level.
 * When set to 1, the auxiliary I2C bus high logic level is V	 * When set to 1, the auxiliary I2C bus high logic level is V
 * 0, the auxiliary I2C bus high logic level is VLOGIC. This 	 * 0, the auxiliary I2C bus high logic level is VLOGIC. This 
 * the MPU-6000, which does not have a VLOGIC pin.		 * the MPU-6000, which does not have a VLOGIC pin.
 * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)	 * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)
 */								 */
void MPU6050_setAuxVDDIOLevel(uint8_t level)		      |	void MPU6050_setAuxVDDIOLevel(uint8_t level) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_YG_OFFS_TC, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_YG_OFFS_T <
	                level);				      <
}								}

// SMPLRT_DIV register						// SMPLRT_DIV register

/** Get gyroscope output rate divider.				/** Get gyroscope output rate divider.
 * The sensor register output, FIFO output, DMP sampling, Mot	 * The sensor register output, FIFO output, DMP sampling, Mot
 * Motion detection, and Free Fall detection are all based on	 * Motion detection, and Free Fall detection are all based on
 * The Sample Rate is generated by dividing the gyroscope out	 * The Sample Rate is generated by dividing the gyroscope out
 * SMPLRT_DIV:							 * SMPLRT_DIV:
 *								 *
 * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)	 * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
 *								 *
 * where Gyroscope Output Rate = 8kHz when the DLPF is disabl	 * where Gyroscope Output Rate = 8kHz when the DLPF is disabl
 * 7), and 1kHz when the DLPF is enabled (see Register 26).	 * 7), and 1kHz when the DLPF is enabled (see Register 26).
 *								 *
 * Note: The accelerometer output rate is 1kHz. This means th	 * Note: The accelerometer output rate is 1kHz. This means th
 * Rate greater than 1kHz, the same accelerometer sample may 	 * Rate greater than 1kHz, the same accelerometer sample may 
 * FIFO, DMP, and sensor registers more than once.		 * FIFO, DMP, and sensor registers more than once.
 *								 *
 * For a diagram of the gyroscope and accelerometer signal pa	 * For a diagram of the gyroscope and accelerometer signal pa
 * of the MPU-6000/MPU-6050 Product Specification document.	 * of the MPU-6000/MPU-6050 Product Specification document.
 *								 *
 * @return Current sample rate					 * @return Current sample rate
 * @see MPU6050_RA_SMPLRT_DIV					 * @see MPU6050_RA_SMPLRT_DIV
 */								 */
uint8_t MPU6050_getRate()				      |	uint8_t MPU6050_getRate() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_SMPLRT_DIV, m
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_SMPLRT_DI |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set gyroscope sample rate divider.				/** Set gyroscope sample rate divider.
 * @param rate New sample rate divider				 * @param rate New sample rate divider
 * @see getRate()						 * @see getRate()
 * @see MPU6050_RA_SMPLRT_DIV					 * @see MPU6050_RA_SMPLRT_DIV
 */								 */
void MPU6050_setRate(uint8_t rate)			      |	void MPU6050_setRate(uint8_t rate) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_SMPLRT_DIV, 
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_SMPLRT_D <
}								}

// CONFIG register						// CONFIG register

/** Get external FSYNC configuration.				/** Get external FSYNC configuration.
 * Configures the external Frame Synchronization (FSYNC) pin 	 * Configures the external Frame Synchronization (FSYNC) pin 
 * external signal connected to the FSYNC pin can be sampled 	 * external signal connected to the FSYNC pin can be sampled 
 * EXT_SYNC_SET. Signal changes to the FSYNC pin are latched 	 * EXT_SYNC_SET. Signal changes to the FSYNC pin are latched 
 * strobes may be captured. The latched FSYNC signal will be 	 * strobes may be captured. The latched FSYNC signal will be 
 * Sampling Rate, as defined in register 25. After sampling, 	 * Sampling Rate, as defined in register 25. After sampling, 
 * reset to the current FSYNC signal state.			 * reset to the current FSYNC signal state.
 *								 *
 * The sampled value will be reported in place of the least s	 * The sampled value will be reported in place of the least s
 * a sensor data register determined by the value of EXT_SYNC	 * a sensor data register determined by the value of EXT_SYNC
 * the following table.						 * the following table.
 *								 *
 * <pre>							 * <pre>
 * EXT_SYNC_SET | FSYNC Bit Location				 * EXT_SYNC_SET | FSYNC Bit Location
 * -------------+-------------------				 * -------------+-------------------
 * 0            | Input disabled				 * 0            | Input disabled
 * 1            | TEMP_OUT_L[0]					 * 1            | TEMP_OUT_L[0]
 * 2            | GYRO_XOUT_L[0]				 * 2            | GYRO_XOUT_L[0]
 * 3            | GYRO_YOUT_L[0]				 * 3            | GYRO_YOUT_L[0]
 * 4            | GYRO_ZOUT_L[0]				 * 4            | GYRO_ZOUT_L[0]
 * 5            | ACCEL_XOUT_L[0]				 * 5            | ACCEL_XOUT_L[0]
 * 6            | ACCEL_YOUT_L[0]				 * 6            | ACCEL_YOUT_L[0]
 * 7            | ACCEL_ZOUT_L[0]				 * 7            | ACCEL_ZOUT_L[0]
 * </pre>							 * </pre>
 *								 *
 * @return FSYNC configuration value				 * @return FSYNC configuration value
 */								 */
uint8_t MPU6050_getExternalFrameSync()			      |	uint8_t MPU6050_getExternalFrameSync() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_CONFIG, MPU60
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_CONFIG,   |	    return mpu6050.buffer[0];
	                MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Set external FSYNC configuration.				/** Set external FSYNC configuration.
 * @see getExternalFrameSync()					 * @see getExternalFrameSync()
 * @see MPU6050_RA_CONFIG					 * @see MPU6050_RA_CONFIG
 * @param sync New FSYNC configuration value			 * @param sync New FSYNC configuration value
 */								 */
void MPU6050_setExternalFrameSync(uint8_t sync)		      |	void MPU6050_setExternalFrameSync(uint8_t sync) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_CONFIG, MPU6
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_CONFIG,  <
	                 MPU6050_CFG_EXT_SYNC_SET_BIT, MPU605 <
}								}
/** Get digital low-pass filter configuration.			/** Get digital low-pass filter configuration.
 * The DLPF_CFG parameter sets the digital low pass filter co	 * The DLPF_CFG parameter sets the digital low pass filter co
 * also determines the internal sampling rate used by the dev	 * also determines the internal sampling rate used by the dev
 * the table below.						 * the table below.
 *								 *
 * Note: The accelerometer output rate is 1kHz. This means th	 * Note: The accelerometer output rate is 1kHz. This means th
 * Rate greater than 1kHz, the same accelerometer sample may 	 * Rate greater than 1kHz, the same accelerometer sample may 
 * FIFO, DMP, and sensor registers more than once.		 * FIFO, DMP, and sensor registers more than once.
 *								 *
 * <pre>							 * <pre>
 *          |   ACCELEROMETER    |           GYROSCOPE		 *          |   ACCELEROMETER    |           GYROSCOPE
 * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sampl	 * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sampl
 * ---------+-----------+--------+-----------+--------+------	 * ---------+-----------+--------+-----------+--------+------
 * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz	 * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz
 * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz	 * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz
 * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz	 * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz
 * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz	 * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz
 * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz	 * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz
 * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz	 * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz
 * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz	 * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz
 * 7        |   -- Reserved --   |   -- Reserved --   | Reser	 * 7        |   -- Reserved --   |   -- Reserved --   | Reser
 * </pre>							 * </pre>
 *								 *
 * @return DLFP configuration					 * @return DLFP configuration
 * @see MPU6050_RA_CONFIG					 * @see MPU6050_RA_CONFIG
 * @see MPU6050_CFG_DLPF_CFG_BIT				 * @see MPU6050_CFG_DLPF_CFG_BIT
 * @see MPU6050_CFG_DLPF_CFG_LENGTH				 * @see MPU6050_CFG_DLPF_CFG_LENGTH
 */								 */
uint8_t MPU6050_getDLPFMode()				      |	uint8_t MPU6050_getDLPFMode() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_CONFIG, MPU60
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_CONFIG, M |	    return mpu6050.buffer[0];
	                MPU6050_CFG_DLPF_CFG_LENGTH, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}
/** Set digital low-pass filter configuration.			/** Set digital low-pass filter configuration.
 * @param mode New DLFP configuration setting			 * @param mode New DLFP configuration setting
 * @see getDLPFBandwidth()					 * @see getDLPFBandwidth()
 * @see MPU6050_DLPF_BW_256					 * @see MPU6050_DLPF_BW_256
 * @see MPU6050_RA_CONFIG					 * @see MPU6050_RA_CONFIG
 * @see MPU6050_CFG_DLPF_CFG_BIT				 * @see MPU6050_CFG_DLPF_CFG_BIT
 * @see MPU6050_CFG_DLPF_CFG_LENGTH				 * @see MPU6050_CFG_DLPF_CFG_LENGTH
 */								 */
void MPU6050_setDLPFMode(uint8_t mode)			      |	void MPU6050_setDLPFMode(uint8_t mode) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_CONFIG, MPU6
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_CONFIG,  <
	                 MPU6050_CFG_DLPF_CFG_LENGTH, mode);  <
}								}

// GYRO_CONFIG register						// GYRO_CONFIG register

/** Get full-scale gyroscope range.				/** Get full-scale gyroscope range.
 * The FS_SEL parameter allows setting the full-scale range o	 * The FS_SEL parameter allows setting the full-scale range o
 * as described in the table below.				 * as described in the table below.
 *								 *
 * <pre>							 * <pre>
 * 0 = +/- 250 degrees/sec					 * 0 = +/- 250 degrees/sec
 * 1 = +/- 500 degrees/sec					 * 1 = +/- 500 degrees/sec
 * 2 = +/- 1000 degrees/sec					 * 2 = +/- 1000 degrees/sec
 * 3 = +/- 2000 degrees/sec					 * 3 = +/- 2000 degrees/sec
 * </pre>							 * </pre>
 *								 *
 * @return Current full-scale gyroscope range setting		 * @return Current full-scale gyroscope range setting
 * @see MPU6050_GYRO_FS_250					 * @see MPU6050_GYRO_FS_250
 * @see MPU6050_RA_GYRO_CONFIG					 * @see MPU6050_RA_GYRO_CONFIG
 * @see MPU6050_GCONFIG_FS_SEL_BIT				 * @see MPU6050_GCONFIG_FS_SEL_BIT
 * @see MPU6050_GCONFIG_FS_SEL_LENGTH				 * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 */								 */
uint8_t MPU6050_getFullScaleGyroRange()			      |	uint8_t MPU6050_getFullScaleGyroRange() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_GYRO_CONFIG, 
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_GYRO_CONF |	    return mpu6050.buffer[0];
	                MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_G <
	return mpu6050.buffer[0];			      <
}								}
/** Set full-scale gyroscope range.				/** Set full-scale gyroscope range.
 * @param range New full-scale gyroscope range value		 * @param range New full-scale gyroscope range value
 * @see getFullScaleRange()					 * @see getFullScaleRange()
 * @see MPU6050_GYRO_FS_250					 * @see MPU6050_GYRO_FS_250
 * @see MPU6050_RA_GYRO_CONFIG					 * @see MPU6050_RA_GYRO_CONFIG
 * @see MPU6050_GCONFIG_FS_SEL_BIT				 * @see MPU6050_GCONFIG_FS_SEL_BIT
 * @see MPU6050_GCONFIG_FS_SEL_LENGTH				 * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 */								 */
void MPU6050_setFullScaleGyroRange(uint8_t range)	      |	void MPU6050_setFullScaleGyroRange(uint8_t range) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_GYRO_CONFIG,
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_GYRO_CON <
	                 MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_ <
}								}

// ACCEL_CONFIG register					// ACCEL_CONFIG register

/** Get self-test enabled setting for accelerometer X axis.	/** Get self-test enabled setting for accelerometer X axis.
 * @return Self-test enabled value				 * @return Self-test enabled value
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
bool MPU6050_getAccelXSelfTest()			      |	bool MPU6050_getAccelXSelfTest() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG, 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONF |	    return mpu6050.buffer[0];
	               MPU6050_ACONFIG_XA_ST_BIT, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}								}
/** Get self-test enabled setting for accelerometer X axis.	/** Get self-test enabled setting for accelerometer X axis.
 * @param enabled Self-test enabled value			 * @param enabled Self-test enabled value
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
void MPU6050_setAccelXSelfTest(bool enabled)		      |	void MPU6050_setAccelXSelfTest(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG,
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CON <
	                MPU6050_ACONFIG_XA_ST_BIT, enabled);  <
}								}
/** Get self-test enabled value for accelerometer Y axis.	/** Get self-test enabled value for accelerometer Y axis.
 * @return Self-test enabled value				 * @return Self-test enabled value
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
bool MPU6050_getAccelYSelfTest()			      |	bool MPU6050_getAccelYSelfTest() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG, 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONF |	    return mpu6050.buffer[0];
	               MPU6050_ACONFIG_YA_ST_BIT, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}								}
/** Get self-test enabled value for accelerometer Y axis.	/** Get self-test enabled value for accelerometer Y axis.
 * @param enabled Self-test enabled value			 * @param enabled Self-test enabled value
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
void MPU6050_setAccelYSelfTest(bool enabled)		      |	void MPU6050_setAccelYSelfTest(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG,
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CON <
	                MPU6050_ACONFIG_YA_ST_BIT, enabled);  <
}								}
/** Get self-test enabled value for accelerometer Z axis.	/** Get self-test enabled value for accelerometer Z axis.
 * @return Self-test enabled value				 * @return Self-test enabled value
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
bool MPU6050_getAccelZSelfTest()			      |	bool MPU6050_getAccelZSelfTest() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG, 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONF |	    return mpu6050.buffer[0];
	               MPU6050_ACONFIG_ZA_ST_BIT, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}								}
/** Set self-test enabled value for accelerometer Z axis.	/** Set self-test enabled value for accelerometer Z axis.
 * @param enabled Self-test enabled value			 * @param enabled Self-test enabled value
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
void MPU6050_setAccelZSelfTest(bool enabled)		      |	void MPU6050_setAccelZSelfTest(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG,
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_ACCEL_CON <
	                MPU6050_ACONFIG_ZA_ST_BIT, enabled);  <
}								}
/** Get full-scale accelerometer range.				/** Get full-scale accelerometer range.
 * The FS_SEL parameter allows setting the full-scale range o	 * The FS_SEL parameter allows setting the full-scale range o
 * sensors, as described in the table below.			 * sensors, as described in the table below.
 *								 *
 * <pre>							 * <pre>
 * 0 = +/- 2g							 * 0 = +/- 2g
 * 1 = +/- 4g							 * 1 = +/- 4g
 * 2 = +/- 8g							 * 2 = +/- 8g
 * 3 = +/- 16g							 * 3 = +/- 16g
 * </pre>							 * </pre>
 *								 *
 * @return Current full-scale accelerometer range setting	 * @return Current full-scale accelerometer range setting
 * @see MPU6050_ACCEL_FS_2					 * @see MPU6050_ACCEL_FS_2
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 * @see MPU6050_ACONFIG_AFS_SEL_BIT				 * @see MPU6050_ACONFIG_AFS_SEL_BIT
 * @see MPU6050_ACONFIG_AFS_SEL_LENGTH				 * @see MPU6050_ACONFIG_AFS_SEL_LENGTH
 */								 */
uint8_t MPU6050_getFullScaleAccelRange()		      |	uint8_t MPU6050_getFullScaleAccelRange() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG,
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CON |	    return mpu6050.buffer[0];
	                MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ <
	return mpu6050.buffer[0];			      <
}								}
/** Set full-scale accelerometer range.				/** Set full-scale accelerometer range.
 * @param range New full-scale accelerometer range setting	 * @param range New full-scale accelerometer range setting
 * @see getFullScaleAccelRange()				 * @see getFullScaleAccelRange()
 */								 */
void MPU6050_setFullScaleAccelRange(uint8_t range)	      |	void MPU6050_setFullScaleAccelRange(uint8_t range) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CO <
	                 MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050 <
}								}
/** Get the high-pass filter configuration.			/** Get the high-pass filter configuration.
 * The DHPF is a filter module in the path leading to motion 	 * The DHPF is a filter module in the path leading to motion 
 * Fall, Motion threshold, and Zero Motion). The high pass fi	 * Fall, Motion threshold, and Zero Motion). The high pass fi
 * available to the data registers (see Figure in Section 8 o	 * available to the data registers (see Figure in Section 8 o
 * MPU-6050 Product Specification document).			 * MPU-6050 Product Specification document).
 *								 *
 * The high pass filter has three modes:			 * The high pass filter has three modes:
 *								 *
 * <pre>							 * <pre>
 *    Reset: The filter output settles to zero within one sam	 *    Reset: The filter output settles to zero within one sam
 *           effectively disables the high pass filter. This 	 *           effectively disables the high pass filter. This 
 *           to quickly settle the filter.			 *           to quickly settle the filter.
 *								 *
 *    On:    The high pass filter will pass signals above the	 *    On:    The high pass filter will pass signals above the
 *								 *
 *    Hold:  When triggered, the filter holds the present sam	 *    Hold:  When triggered, the filter holds the present sam
 *           output will be the difference between the input 	 *           output will be the difference between the input 
 *           sample.						 *           sample.
 * </pre>							 * </pre>
 *								 *
 * <pre>							 * <pre>
 * ACCEL_HPF | Filter Mode | Cut-off Frequency			 * ACCEL_HPF | Filter Mode | Cut-off Frequency
 * ----------+-------------+------------------			 * ----------+-------------+------------------
 * 0         | Reset       | None				 * 0         | Reset       | None
 * 1         | On          | 5Hz				 * 1         | On          | 5Hz
 * 2         | On          | 2.5Hz				 * 2         | On          | 2.5Hz
 * 3         | On          | 1.25Hz				 * 3         | On          | 1.25Hz
 * 4         | On          | 0.63Hz				 * 4         | On          | 0.63Hz
 * 7         | Hold        | None				 * 7         | Hold        | None
 * </pre>							 * </pre>
 *								 *
 * @return Current high-pass filter configuration		 * @return Current high-pass filter configuration
 * @see MPU6050_DHPF_RESET					 * @see MPU6050_DHPF_RESET
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
uint8_t MPU6050_getDHPFMode()				      |	uint8_t MPU6050_getDHPFMode() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG,
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CON |	    return mpu6050.buffer[0];
	                MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU605 <
	                mpu6050.buffer);		      <
	return mpu6050.buffer[0];			      <
}								}
/** Set the high-pass filter configuration.			/** Set the high-pass filter configuration.
 * @param bandwidth New high-pass filter configuration		 * @param bandwidth New high-pass filter configuration
 * @see setDHPFMode()						 * @see setDHPFMode()
 * @see MPU6050_DHPF_RESET					 * @see MPU6050_DHPF_RESET
 * @see MPU6050_RA_ACCEL_CONFIG					 * @see MPU6050_RA_ACCEL_CONFIG
 */								 */
void MPU6050_setDHPFMode(uint8_t bandwidth)		      |	void MPU6050_setDHPFMode(uint8_t bandwidth) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CONFIG
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_ACCEL_CO <
	                 MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU60 <
}								}

// FF_THR register						// FF_THR register

/** Get free-fall event acceleration threshold.			/** Get free-fall event acceleration threshold.
 * This register configures the detection threshold for Free 	 * This register configures the detection threshold for Free 
 * detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is 	 * detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is 
 * absolute value of the accelerometer measurements for the t	 * absolute value of the accelerometer measurements for the t
 * less than the detection threshold. This condition incremen	 * less than the detection threshold. This condition incremen
 * duration counter (Register 30). The Free Fall interrupt is	 * duration counter (Register 30). The Free Fall interrupt is
 * Free Fall duration counter reaches the time specified in F	 * Free Fall duration counter reaches the time specified in F
 *								 *
 * For more details on the Free Fall detection interrupt, see	 * For more details on the Free Fall detection interrupt, see
 * MPU-6000/MPU-6050 Product Specification document as well a	 * MPU-6000/MPU-6050 Product Specification document as well a
 * 58 of this document.						 * 58 of this document.
 *								 *
 * @return Current free-fall acceleration threshold value (LS	 * @return Current free-fall acceleration threshold value (LS
 * @see MPU6050_RA_FF_THR					 * @see MPU6050_RA_FF_THR
 */								 */
uint8_t MPU6050_getFreefallDetectionThreshold()		      |	uint8_t MPU6050_getFreefallDetectionThreshold() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_FF_THR, mpu60
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_FF_THR, m |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Get free-fall event acceleration threshold.			/** Get free-fall event acceleration threshold.
 * @param threshold New free-fall acceleration threshold valu	 * @param threshold New free-fall acceleration threshold valu
 * @see getFreefallDetectionThreshold()				 * @see getFreefallDetectionThreshold()
 * @see MPU6050_RA_FF_THR					 * @see MPU6050_RA_FF_THR
 */								 */
void MPU6050_setFreefallDetectionThreshold(uint8_t threshold) |	void MPU6050_setFreefallDetectionThreshold(uint8_t threshold)
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_FF_THR, thre
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_FF_THR,  <
}								}

// FF_DUR register						// FF_DUR register

/** Get free-fall event duration threshold.			/** Get free-fall event duration threshold.
 * This register configures the duration counter threshold fo	 * This register configures the duration counter threshold fo
 * detection. The duration counter ticks at 1kHz, therefore F	 * detection. The duration counter ticks at 1kHz, therefore F
 * of 1 LSB = 1 ms.						 * of 1 LSB = 1 ms.
 *								 *
 * The Free Fall duration counter increments while the absolu	 * The Free Fall duration counter increments while the absolu
 * accelerometer measurements are each less than the detectio	 * accelerometer measurements are each less than the detectio
 * (Register 29). The Free Fall interrupt is triggered when t	 * (Register 29). The Free Fall interrupt is triggered when t
 * duration counter reaches the time specified in this regist	 * duration counter reaches the time specified in this regist
 *								 *
 * For more details on the Free Fall detection interrupt, see	 * For more details on the Free Fall detection interrupt, see
 * the MPU-6000/MPU-6050 Product Specification document as we	 * the MPU-6000/MPU-6050 Product Specification document as we
 * and 58 of this document.					 * and 58 of this document.
 *								 *
 * @return Current free-fall duration threshold value (LSB = 	 * @return Current free-fall duration threshold value (LSB = 
 * @see MPU6050_RA_FF_DUR					 * @see MPU6050_RA_FF_DUR
 */								 */
uint8_t MPU6050_getFreefallDetectionDuration()		      |	uint8_t MPU6050_getFreefallDetectionDuration() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_FF_DUR, mpu60
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_FF_DUR, m |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Get free-fall event duration threshold.			/** Get free-fall event duration threshold.
 * @param duration New free-fall duration threshold value (LS	 * @param duration New free-fall duration threshold value (LS
 * @see getFreefallDetectionDuration()				 * @see getFreefallDetectionDuration()
 * @see MPU6050_RA_FF_DUR					 * @see MPU6050_RA_FF_DUR
 */								 */
void MPU6050_setFreefallDetectionDuration(uint8_t duration)   |	void MPU6050_setFreefallDetectionDuration(uint8_t duration) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_FF_DUR, dura
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_FF_DUR,  <
}								}

// MOT_THR register						// MOT_THR register

/** Get motion detection event acceleration threshold.		/** Get motion detection event acceleration threshold.
 * This register configures the detection threshold for Motio	 * This register configures the detection threshold for Motio
 * generation. The unit of MOT_THR is 1LSB = 2mg. Motion is d	 * generation. The unit of MOT_THR is 1LSB = 2mg. Motion is d
 * absolute value of any of the accelerometer measurements ex	 * absolute value of any of the accelerometer measurements ex
 * detection threshold. This condition increments the Motion 	 * detection threshold. This condition increments the Motion 
 * counter (Register 32). The Motion detection interrupt is t	 * counter (Register 32). The Motion detection interrupt is t
 * Motion Detection counter reaches the time count specified 	 * Motion Detection counter reaches the time count specified 
 * (Register 32).						 * (Register 32).
 *								 *
 * The Motion interrupt will indicate the axis and polarity o	 * The Motion interrupt will indicate the axis and polarity o
 * in MOT_DETECT_STATUS (Register 97).				 * in MOT_DETECT_STATUS (Register 97).
 *								 *
 * For more details on the Motion detection interrupt, see Se	 * For more details on the Motion detection interrupt, see Se
 * MPU-6000/MPU-6050 Product Specification document as well a	 * MPU-6000/MPU-6050 Product Specification document as well a
 * 58 of this document.						 * 58 of this document.
 *								 *
 * @return Current motion detection acceleration threshold va	 * @return Current motion detection acceleration threshold va
 * @see MPU6050_RA_MOT_THR					 * @see MPU6050_RA_MOT_THR
 */								 */
uint8_t MPU6050_getMotionDetectionThreshold()		      |	uint8_t MPU6050_getMotionDetectionThreshold() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_MOT_THR, mpu6
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_MOT_THR,  |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set free-fall event acceleration threshold.			/** Set free-fall event acceleration threshold.
 * @param threshold New motion detection acceleration thresho	 * @param threshold New motion detection acceleration thresho
 * @see getMotionDetectionThreshold()				 * @see getMotionDetectionThreshold()
 * @see MPU6050_RA_MOT_THR					 * @see MPU6050_RA_MOT_THR
 */								 */
void MPU6050_setMotionDetectionThreshold(uint8_t threshold)   |	void MPU6050_setMotionDetectionThreshold(uint8_t threshold) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MOT_THR, thr
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MOT_THR, <
}								}

// MOT_DUR register						// MOT_DUR register

/** Get motion detection event duration threshold.		/** Get motion detection event duration threshold.
 * This register configures the duration counter threshold fo	 * This register configures the duration counter threshold fo
 * generation. The duration counter ticks at 1 kHz, therefore	 * generation. The duration counter ticks at 1 kHz, therefore
 * of 1LSB = 1ms. The Motion detection duration counter incre	 * of 1LSB = 1ms. The Motion detection duration counter incre
 * absolute value of any of the accelerometer measurements ex	 * absolute value of any of the accelerometer measurements ex
 * detection threshold (Register 31). The Motion detection in	 * detection threshold (Register 31). The Motion detection in
 * triggered when the Motion detection counter reaches the ti	 * triggered when the Motion detection counter reaches the ti
 * in this register.						 * in this register.
 *								 *
 * For more details on the Motion detection interrupt, see Se	 * For more details on the Motion detection interrupt, see Se
 * MPU-6000/MPU-6050 Product Specification document.		 * MPU-6000/MPU-6050 Product Specification document.
 *								 *
 * @return Current motion detection duration threshold value 	 * @return Current motion detection duration threshold value 
 * @see MPU6050_RA_MOT_DUR					 * @see MPU6050_RA_MOT_DUR
 */								 */
uint8_t MPU6050_getMotionDetectionDuration()		      |	uint8_t MPU6050_getMotionDetectionDuration() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_MOT_DUR, mpu6
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_MOT_DUR,  |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set motion detection event duration threshold.		/** Set motion detection event duration threshold.
 * @param duration New motion detection duration threshold va	 * @param duration New motion detection duration threshold va
 * @see getMotionDetectionDuration()				 * @see getMotionDetectionDuration()
 * @see MPU6050_RA_MOT_DUR					 * @see MPU6050_RA_MOT_DUR
 */								 */
void MPU6050_setMotionDetectionDuration(uint8_t duration)     |	void MPU6050_setMotionDetectionDuration(uint8_t duration) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MOT_DUR, dur
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MOT_DUR, <
}								}

// ZRMOT_THR register						// ZRMOT_THR register

/** Get zero motion detection event acceleration threshold.	/** Get zero motion detection event acceleration threshold.
 * This register configures the detection threshold for Zero 	 * This register configures the detection threshold for Zero 
 * generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Moti	 * generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Moti
 * the absolute value of the accelerometer measurements for t	 * the absolute value of the accelerometer measurements for t
 * less than the detection threshold. This condition incremen	 * less than the detection threshold. This condition incremen
 * duration counter (Register 34). The Zero Motion interrupt 	 * duration counter (Register 34). The Zero Motion interrupt 
 * the Zero Motion duration counter reaches the time count sp	 * the Zero Motion duration counter reaches the time count sp
 * ZRMOT_DUR (Register 34).					 * ZRMOT_DUR (Register 34).
 *								 *
 * Unlike Free Fall or Motion detection, Zero Motion detectio	 * Unlike Free Fall or Motion detection, Zero Motion detectio
 * interrupt both when Zero Motion is first detected and when	 * interrupt both when Zero Motion is first detected and when
 * longer detected.						 * longer detected.
 *								 *
 * When a zero motion event is detected, a Zero Motion Status	 * When a zero motion event is detected, a Zero Motion Status
 * in the MOT_DETECT_STATUS register (Register 97). When a mo	 * in the MOT_DETECT_STATUS register (Register 97). When a mo
 * condition is detected, the status bit is set to 1. When a 	 * condition is detected, the status bit is set to 1. When a 
 * motion condition is detected, the status bit is set to 0.	 * motion condition is detected, the status bit is set to 0.
 *								 *
 * For more details on the Zero Motion detection interrupt, s	 * For more details on the Zero Motion detection interrupt, s
 * the MPU-6000/MPU-6050 Product Specification document as we	 * the MPU-6000/MPU-6050 Product Specification document as we
 * and 58 of this document.					 * and 58 of this document.
 *								 *
 * @return Current zero motion detection acceleration thresho	 * @return Current zero motion detection acceleration thresho
 * @see MPU6050_RA_ZRMOT_THR					 * @see MPU6050_RA_ZRMOT_THR
 */								 */
uint8_t MPU6050_getZeroMotionDetectionThreshold()	      |	uint8_t MPU6050_getZeroMotionDetectionThreshold() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_THR, mp
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_THR |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set zero motion detection event acceleration threshold.	/** Set zero motion detection event acceleration threshold.
 * @param threshold New zero motion detection acceleration th	 * @param threshold New zero motion detection acceleration th
 * @see getZeroMotionDetectionThreshold()			 * @see getZeroMotionDetectionThreshold()
 * @see MPU6050_RA_ZRMOT_THR					 * @see MPU6050_RA_ZRMOT_THR
 */								 */
void MPU6050_setZeroMotionDetectionThreshold(uint8_t threshol |	void MPU6050_setZeroMotionDetectionThreshold(uint8_t threshol
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_THR, t
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_TH <
}								}

// ZRMOT_DUR register						// ZRMOT_DUR register

/** Get zero motion detection event duration threshold.		/** Get zero motion detection event duration threshold.
 * This register configures the duration counter threshold fo	 * This register configures the duration counter threshold fo
 * interrupt generation. The duration counter ticks at 16 Hz,	 * interrupt generation. The duration counter ticks at 16 Hz,
 * ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion dur	 * ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion dur
 * increments while the absolute value of the accelerometer m	 * increments while the absolute value of the accelerometer m
 * each less than the detection threshold (Register 33). The 	 * each less than the detection threshold (Register 33). The 
 * interrupt is triggered when the Zero Motion duration count	 * interrupt is triggered when the Zero Motion duration count
 * count specified in this register.				 * count specified in this register.
 *								 *
 * For more details on the Zero Motion detection interrupt, s	 * For more details on the Zero Motion detection interrupt, s
 * the MPU-6000/MPU-6050 Product Specification document, as w	 * the MPU-6000/MPU-6050 Product Specification document, as w
 * and 58 of this document.					 * and 58 of this document.
 *								 *
 * @return Current zero motion detection duration threshold v	 * @return Current zero motion detection duration threshold v
 * @see MPU6050_RA_ZRMOT_DUR					 * @see MPU6050_RA_ZRMOT_DUR
 */								 */
uint8_t MPU6050_getZeroMotionDetectionDuration()	      |	uint8_t MPU6050_getZeroMotionDetectionDuration() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_DUR, mp
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_DUR |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set zero motion detection event duration threshold.		/** Set zero motion detection event duration threshold.
 * @param duration New zero motion detection duration thresho	 * @param duration New zero motion detection duration thresho
 * @see getZeroMotionDetectionDuration()			 * @see getZeroMotionDetectionDuration()
 * @see MPU6050_RA_ZRMOT_DUR					 * @see MPU6050_RA_ZRMOT_DUR
 */								 */
void MPU6050_setZeroMotionDetectionDuration(uint8_t duration) |	void MPU6050_setZeroMotionDetectionDuration(uint8_t duration)
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_DUR, d
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_ZRMOT_DU <
}								}

// FIFO_EN register						// FIFO_EN register

/** Get temperature FIFO enabled value.				/** Get temperature FIFO enabled value.
 * When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L 	 * When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L 
 * 66) to be written into the FIFO mpu6050.buffer.		 * 66) to be written into the FIFO mpu6050.buffer.
 * @return Current temperature FIFO enabled value		 * @return Current temperature FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getTempFIFOEnabled()			      |	bool MPU6050_getTempFIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set temperature FIFO enabled value.				/** Set temperature FIFO enabled value.
 * @param enabled New temperature FIFO enabled value		 * @param enabled New temperature FIFO enabled value
 * @see getTempFIFOEnabled()					 * @see getTempFIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setTempFIFOEnabled(bool enabled)		      |	void MPU6050_setTempFIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}
/** Get gyroscope X-axis FIFO enabled value.			/** Get gyroscope X-axis FIFO enabled value.
 * When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_	 * When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_
 * 68) to be written into the FIFO mpu6050.buffer.		 * 68) to be written into the FIFO mpu6050.buffer.
 * @return Current gyroscope X-axis FIFO enabled value		 * @return Current gyroscope X-axis FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getXGyroFIFOEnabled()			      |	bool MPU6050_getXGyroFIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set gyroscope X-axis FIFO enabled value.			/** Set gyroscope X-axis FIFO enabled value.
 * @param enabled New gyroscope X-axis FIFO enabled value	 * @param enabled New gyroscope X-axis FIFO enabled value
 * @see getXGyroFIFOEnabled()					 * @see getXGyroFIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setXGyroFIFOEnabled(bool enabled)		      |	void MPU6050_setXGyroFIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}
/** Get gyroscope Y-axis FIFO enabled value.			/** Get gyroscope Y-axis FIFO enabled value.
 * When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_	 * When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_
 * 70) to be written into the FIFO mpu6050.buffer.		 * 70) to be written into the FIFO mpu6050.buffer.
 * @return Current gyroscope Y-axis FIFO enabled value		 * @return Current gyroscope Y-axis FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getYGyroFIFOEnabled()			      |	bool MPU6050_getYGyroFIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set gyroscope Y-axis FIFO enabled value.			/** Set gyroscope Y-axis FIFO enabled value.
 * @param enabled New gyroscope Y-axis FIFO enabled value	 * @param enabled New gyroscope Y-axis FIFO enabled value
 * @see getYGyroFIFOEnabled()					 * @see getYGyroFIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setYGyroFIFOEnabled(bool enabled)		      |	void MPU6050_setYGyroFIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}
/** Get gyroscope Z-axis FIFO enabled value.			/** Get gyroscope Z-axis FIFO enabled value.
 * When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_	 * When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_
 * 72) to be written into the FIFO mpu6050.buffer.		 * 72) to be written into the FIFO mpu6050.buffer.
 * @return Current gyroscope Z-axis FIFO enabled value		 * @return Current gyroscope Z-axis FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getZGyroFIFOEnabled()			      |	bool MPU6050_getZGyroFIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set gyroscope Z-axis FIFO enabled value.			/** Set gyroscope Z-axis FIFO enabled value.
 * @param enabled New gyroscope Z-axis FIFO enabled value	 * @param enabled New gyroscope Z-axis FIFO enabled value
 * @see getZGyroFIFOEnabled()					 * @see getZGyroFIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setZGyroFIFOEnabled(bool enabled)		      |	void MPU6050_setZGyroFIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}
/** Get accelerometer FIFO enabled value.			/** Get accelerometer FIFO enabled value.
 * When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L	 * When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L
 * ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59	 * ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59
 * written into the FIFO mpu6050.buffer.			 * written into the FIFO mpu6050.buffer.
 * @return Current accelerometer FIFO enabled value		 * @return Current accelerometer FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getAccelFIFOEnabled()			      |	bool MPU6050_getAccelFIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set accelerometer FIFO enabled value.			/** Set accelerometer FIFO enabled value.
 * @param enabled New accelerometer FIFO enabled value		 * @param enabled New accelerometer FIFO enabled value
 * @see getAccelFIFOEnabled()					 * @see getAccelFIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setAccelFIFOEnabled(bool enabled)		      |	void MPU6050_setAccelFIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}
/** Get Slave 2 FIFO enabled value.				/** Get Slave 2 FIFO enabled value.
 * When set to 1, this bit enables EXT_SENS_DATA registers (R	 * When set to 1, this bit enables EXT_SENS_DATA registers (R
 * associated with Slave 2 to be written into the FIFO mpu605	 * associated with Slave 2 to be written into the FIFO mpu605
 * @return Current Slave 2 FIFO enabled value			 * @return Current Slave 2 FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getSlave2FIFOEnabled()			      |	bool MPU6050_getSlave2FIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Slave 2 FIFO enabled value.				/** Set Slave 2 FIFO enabled value.
 * @param enabled New Slave 2 FIFO enabled value		 * @param enabled New Slave 2 FIFO enabled value
 * @see getSlave2FIFOEnabled()					 * @see getSlave2FIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setSlave2FIFOEnabled(bool enabled)		      |	void MPU6050_setSlave2FIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}
/** Get Slave 1 FIFO enabled value.				/** Get Slave 1 FIFO enabled value.
 * When set to 1, this bit enables EXT_SENS_DATA registers (R	 * When set to 1, this bit enables EXT_SENS_DATA registers (R
 * associated with Slave 1 to be written into the FIFO mpu605	 * associated with Slave 1 to be written into the FIFO mpu605
 * @return Current Slave 1 FIFO enabled value			 * @return Current Slave 1 FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getSlave1FIFOEnabled()			      |	bool MPU6050_getSlave1FIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Slave 1 FIFO enabled value.				/** Set Slave 1 FIFO enabled value.
 * @param enabled New Slave 1 FIFO enabled value		 * @param enabled New Slave 1 FIFO enabled value
 * @see getSlave1FIFOEnabled()					 * @see getSlave1FIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setSlave1FIFOEnabled(bool enabled)		      |	void MPU6050_setSlave1FIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}
/** Get Slave 0 FIFO enabled value.				/** Get Slave 0 FIFO enabled value.
 * When set to 1, this bit enables EXT_SENS_DATA registers (R	 * When set to 1, this bit enables EXT_SENS_DATA registers (R
 * associated with Slave 0 to be written into the FIFO mpu605	 * associated with Slave 0 to be written into the FIFO mpu605
 * @return Current Slave 0 FIFO enabled value			 * @return Current Slave 0 FIFO enabled value
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
bool MPU6050_getSlave0FIFOEnabled()			      |	bool MPU6050_getSlave0FIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU60
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, M |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Slave 0 FIFO enabled value.				/** Set Slave 0 FIFO enabled value.
 * @param enabled New Slave 0 FIFO enabled value		 * @param enabled New Slave 0 FIFO enabled value
 * @see getSlave0FIFOEnabled()					 * @see getSlave0FIFOEnabled()
 * @see MPU6050_RA_FIFO_EN					 * @see MPU6050_RA_FIFO_EN
 */								 */
void MPU6050_setSlave0FIFOEnabled(bool enabled)		      |	void MPU6050_setSlave0FIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN, MPU6
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_FIFO_EN,  <
	                enabled);			      <
}								}

// I2C_MST_CTRL register					// I2C_MST_CTRL register

/** Get multi-master enabled value.				/** Get multi-master enabled value.
 * Multi-master capability allows multiple I2C masters to ope	 * Multi-master capability allows multiple I2C masters to ope
 * bus. In circuits where multi-master capability is required	 * bus. In circuits where multi-master capability is required
 * to 1. This will increase current drawn by approximately 30	 * to 1. This will increase current drawn by approximately 30
 *								 *
 * In circuits where multi-master capability is required, the	 * In circuits where multi-master capability is required, the
 * bus must always be monitored by each separate I2C Master. 	 * bus must always be monitored by each separate I2C Master. 
 * Master can assume arbitration of the bus, it must first co	 * Master can assume arbitration of the bus, it must first co
 * I2C Master has arbitration of the bus. When MULT_MST_EN is	 * I2C Master has arbitration of the bus. When MULT_MST_EN is
 * MPU-60X0's bus arbitration detection logic is turned on, e	 * MPU-60X0's bus arbitration detection logic is turned on, e
 * detect when the bus is available.				 * detect when the bus is available.
 *								 *
 * @return Current multi-master enabled value			 * @return Current multi-master enabled value
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
bool MPU6050_getMultiMasterEnabled()			      |	bool MPU6050_getMultiMasterEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL, 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CT |	    return mpu6050.buffer[0];
	               MPU6050_MULT_MST_EN_BIT, mpu6050.buffe <
	return mpu6050.buffer[0];			      <
}								}
/** Set multi-master enabled value.				/** Set multi-master enabled value.
 * @param enabled New multi-master enabled value		 * @param enabled New multi-master enabled value
 * @see getMultiMasterEnabled()					 * @see getMultiMasterEnabled()
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
void MPU6050_setMultiMasterEnabled(bool enabled)	      |	void MPU6050_setMultiMasterEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL,
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_C <
	                MPU6050_MULT_MST_EN_BIT, enabled);    <
}								}
/** Get wait-for-external-sensor-data enabled value.		/** Get wait-for-external-sensor-data enabled value.
 * When the WAIT_FOR_ES bit is set to 1, the Data Ready inter	 * When the WAIT_FOR_ES bit is set to 1, the Data Ready inter
 * delayed until External Sensor data from the Slave Devices 	 * delayed until External Sensor data from the Slave Devices 
 * EXT_SENS_DATA registers. This is used to ensure that both 	 * EXT_SENS_DATA registers. This is used to ensure that both 
 * data (i.e. from gyro and accel) and external sensor data h	 * data (i.e. from gyro and accel) and external sensor data h
 * their respective data registers (i.e. the data is synced) 	 * their respective data registers (i.e. the data is synced) 
 * interrupt is triggered.					 * interrupt is triggered.
 *								 *
 * @return Current wait-for-external-sensor-data enabled valu	 * @return Current wait-for-external-sensor-data enabled valu
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
bool MPU6050_getWaitForExternalSensorEnabled()		      |	bool MPU6050_getWaitForExternalSensorEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL, 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CT |	    return mpu6050.buffer[0];
	               MPU6050_WAIT_FOR_ES_BIT, mpu6050.buffe <
	return mpu6050.buffer[0];			      <
}								}
/** Set wait-for-external-sensor-data enabled value.		/** Set wait-for-external-sensor-data enabled value.
 * @param enabled New wait-for-external-sensor-data enabled v	 * @param enabled New wait-for-external-sensor-data enabled v
 * @see getWaitForExternalSensorEnabled()			 * @see getWaitForExternalSensorEnabled()
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
void MPU6050_setWaitForExternalSensorEnabled(bool enabled)    |	void MPU6050_setWaitForExternalSensorEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL,
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_C <
	                MPU6050_WAIT_FOR_ES_BIT, enabled);    <
}								}
/** Get Slave 3 FIFO enabled value.				/** Get Slave 3 FIFO enabled value.
 * When set to 1, this bit enables EXT_SENS_DATA registers (R	 * When set to 1, this bit enables EXT_SENS_DATA registers (R
 * associated with Slave 3 to be written into the FIFO mpu605	 * associated with Slave 3 to be written into the FIFO mpu605
 * @return Current Slave 3 FIFO enabled value			 * @return Current Slave 3 FIFO enabled value
 * @see MPU6050_RA_MST_CTRL					 * @see MPU6050_RA_MST_CTRL
 */								 */
bool MPU6050_getSlave3FIFOEnabled()			      |	bool MPU6050_getSlave3FIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL, 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CT |	    return mpu6050.buffer[0];
	               MPU6050_SLV_3_FIFO_EN_BIT, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}								}
/** Set Slave 3 FIFO enabled value.				/** Set Slave 3 FIFO enabled value.
 * @param enabled New Slave 3 FIFO enabled value		 * @param enabled New Slave 3 FIFO enabled value
 * @see getSlave3FIFOEnabled()					 * @see getSlave3FIFOEnabled()
 * @see MPU6050_RA_MST_CTRL					 * @see MPU6050_RA_MST_CTRL
 */								 */
void MPU6050_setSlave3FIFOEnabled(bool enabled)		      |	void MPU6050_setSlave3FIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL,
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_C <
	                MPU6050_SLV_3_FIFO_EN_BIT, enabled);  <
}								}
/** Get slave read/write transition enabled value.		/** Get slave read/write transition enabled value.
 * The I2C_MST_P_NSR bit configures the I2C Master's transiti	 * The I2C_MST_P_NSR bit configures the I2C Master's transiti
 * read to the next slave read. If the bit equals 0, there wi	 * read to the next slave read. If the bit equals 0, there wi
 * between reads. If the bit equals 1, there will be a stop f	 * between reads. If the bit equals 1, there will be a stop f
 * of the following read. When a write transaction follows a 	 * of the following read. When a write transaction follows a 
 * the stop followed by a start of the successive write will 	 * the stop followed by a start of the successive write will 
 *								 *
 * @return Current slave read/write transition enabled value	 * @return Current slave read/write transition enabled value
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
bool MPU6050_getSlaveReadWriteTransitionEnabled()	      |	bool MPU6050_getSlaveReadWriteTransitionEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL, 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CT |	    return mpu6050.buffer[0];
	               MPU6050_I2C_MST_P_NSR_BIT, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}								}
/** Set slave read/write transition enabled value.		/** Set slave read/write transition enabled value.
 * @param enabled New slave read/write transition enabled val	 * @param enabled New slave read/write transition enabled val
 * @see getSlaveReadWriteTransitionEnabled()			 * @see getSlaveReadWriteTransitionEnabled()
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
void MPU6050_setSlaveReadWriteTransitionEnabled(bool enabled) |	void MPU6050_setSlaveReadWriteTransitionEnabled(bool enabled)
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL,
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_C <
	                MPU6050_I2C_MST_P_NSR_BIT, enabled);  <
}								}
/** Get I2C master clock speed.					/** Get I2C master clock speed.
 * I2C_MST_CLK is a 4 bit unsigned value which configures a d	 * I2C_MST_CLK is a 4 bit unsigned value which configures a d
 * MPU-60X0 internal 8MHz clock. It sets the I2C master clock	 * MPU-60X0 internal 8MHz clock. It sets the I2C master clock
 * the following table:						 * the following table:
 *								 *
 * <pre>							 * <pre>
 * I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider	 * I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider
 * ------------+------------------------+-------------------	 * ------------+------------------------+-------------------
 * 0           | 348kHz                 | 23			 * 0           | 348kHz                 | 23
 * 1           | 333kHz                 | 24			 * 1           | 333kHz                 | 24
 * 2           | 320kHz                 | 25			 * 2           | 320kHz                 | 25
 * 3           | 308kHz                 | 26			 * 3           | 308kHz                 | 26
 * 4           | 296kHz                 | 27			 * 4           | 296kHz                 | 27
 * 5           | 286kHz                 | 28			 * 5           | 286kHz                 | 28
 * 6           | 276kHz                 | 29			 * 6           | 276kHz                 | 29
 * 7           | 267kHz                 | 30			 * 7           | 267kHz                 | 30
 * 8           | 258kHz                 | 31			 * 8           | 258kHz                 | 31
 * 9           | 500kHz                 | 16			 * 9           | 500kHz                 | 16
 * 10          | 471kHz                 | 17			 * 10          | 471kHz                 | 17
 * 11          | 444kHz                 | 18			 * 11          | 444kHz                 | 18
 * 12          | 421kHz                 | 19			 * 12          | 421kHz                 | 19
 * 13          | 400kHz                 | 20			 * 13          | 400kHz                 | 20
 * 14          | 381kHz                 | 21			 * 14          | 381kHz                 | 21
 * 15          | 364kHz                 | 22			 * 15          | 364kHz                 | 22
 * </pre>							 * </pre>
 *								 *
 * @return Current I2C master clock speed			 * @return Current I2C master clock speed
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
uint8_t MPU6050_getMasterClockSpeed()			      |	uint8_t MPU6050_getMasterClockSpeed() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL,
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_I2C_MST_C |	    return mpu6050.buffer[0];
	                MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C_ <
	return mpu6050.buffer[0];			      <
}								}
/** Set I2C master clock speed.					/** Set I2C master clock speed.
 * @reparam speed Current I2C master clock speed		 * @reparam speed Current I2C master clock speed
 * @see MPU6050_RA_I2C_MST_CTRL					 * @see MPU6050_RA_I2C_MST_CTRL
 */								 */
void MPU6050_setMasterClockSpeed(uint8_t speed)		      |	void MPU6050_setMasterClockSpeed(uint8_t speed) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_I2C_MST_CTRL
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_I2C_MST_ <
	                 MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C <
}								}

// I2C_SLV* registers (Slave 0-3)				// I2C_SLV* registers (Slave 0-3)

/** Get the I2C address of the specified slave (0-3).		/** Get the I2C address of the specified slave (0-3).
 * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 i	 * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 i
 * operation, and if it is cleared, then it's a write operati	 * operation, and if it is cleared, then it's a write operati
 * bits (6-0) are the 7-bit device address of the slave devic	 * bits (6-0) are the 7-bit device address of the slave devic
 *								 *
 * In read mode, the result of the read is placed in the lowe |	 * In read mode, the result of the read is placed in the lowe
 * EXT_SENS_DATA register. For further information regarding 	 * EXT_SENS_DATA register. For further information regarding 
 * read results, please refer to the EXT_SENS_DATA register d	 * read results, please refer to the EXT_SENS_DATA register d
 * (Registers 73 - 96).						 * (Registers 73 - 96).
 *								 *
 * The MPU-6050 supports a total of five slaves, but Slave 4 	 * The MPU-6050 supports a total of five slaves, but Slave 4 
 * characteristics, and so it has its own functions (getSlave	 * characteristics, and so it has its own functions (getSlave
 *								 *
 * I2C data transactions are performed at the Sample Rate, as	 * I2C data transactions are performed at the Sample Rate, as
 * Register 25. The user is responsible for ensuring that I2C	 * Register 25. The user is responsible for ensuring that I2C
 * to and from each enabled Slave can be completed within a s	 * to and from each enabled Slave can be completed within a s
 * Sample Rate.							 * Sample Rate.
 *								 *
 * The I2C slave access rate can be reduced relative to the S	 * The I2C slave access rate can be reduced relative to the S
 * reduced access rate is determined by I2C_MST_DLY (Register	 * reduced access rate is determined by I2C_MST_DLY (Register
 * slave's access rate is reduced relative to the Sample Rate	 * slave's access rate is reduced relative to the Sample Rate
 * I2C_MST_DELAY_CTRL (Register 103).				 * I2C_MST_DELAY_CTRL (Register 103).
 *								 *
 * The processing order for the slaves is fixed. The sequence	 * The processing order for the slaves is fixed. The sequence
 * processing the slaves is Slave 0, Slave 1, Slave 2, Slave 	 * processing the slaves is Slave 0, Slave 1, Slave 2, Slave 
 * particular Slave is disabled it will be skipped.		 * particular Slave is disabled it will be skipped.
 *								 *
 * Each slave can either be accessed at the sample rate or at	 * Each slave can either be accessed at the sample rate or at
 * rate. In a case where some slaves are accessed at the Samp	 * rate. In a case where some slaves are accessed at the Samp
 * slaves are accessed at the reduced rate, the sequence of a	 * slaves are accessed at the reduced rate, the sequence of a
 * (Slave 0 to Slave 4) is still followed. However, the reduc	 * (Slave 0 to Slave 4) is still followed. However, the reduc
 * be skipped if their access rate dictates that they should 	 * be skipped if their access rate dictates that they should 
 * during that particular cycle. For further information rega	 * during that particular cycle. For further information rega
 * access rate, please refer to Register 52. Whether a slave 	 * access rate, please refer to Register 52. Whether a slave 
 * Sample Rate or at the reduced rate is determined by the De	 * Sample Rate or at the reduced rate is determined by the De
 * Register 103.						 * Register 103.
 *								 *
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @return Current address for specified slave			 * @return Current address for specified slave
 * @see MPU6050_RA_I2C_SLV0_ADDR				 * @see MPU6050_RA_I2C_SLV0_ADDR
 */								 */
uint8_t MPU6050_getSlaveAddress(uint8_t num)		      |	uint8_t MPU6050_getSlaveAddress(uint8_t num) {
{							      |	    if (num > 3) return 0;
	if (num > 3) return 0;				      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ADDR
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ |	    return mpu6050.buffer[0];
	                mpu6050.buffer);		      <
	return mpu6050.buffer[0];			      <
}								}
/** Set the I2C address of the specified slave (0-3).		/** Set the I2C address of the specified slave (0-3).
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param address New address for specified slave		 * @param address New address for specified slave
 * @see getSlaveAddress()					 * @see getSlaveAddress()
 * @see MPU6050_RA_I2C_SLV0_ADDR				 * @see MPU6050_RA_I2C_SLV0_ADDR
 */								 */
void MPU6050_setSlaveAddress(uint8_t num, uint8_t address)    |	void MPU6050_setSlaveAddress(uint8_t num, uint8_t address) {
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ADD
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0 <
}								}
/** Get the active internal register for the specified slave 	/** Get the active internal register for the specified slave 
 * Read/write operations for this slave will be done to whate	 * Read/write operations for this slave will be done to whate
 * register address is stored in this MPU register.		 * register address is stored in this MPU register.
 *								 *
 * The MPU-6050 supports a total of five slaves, but Slave 4 	 * The MPU-6050 supports a total of five slaves, but Slave 4 
 * characteristics, and so it has its own functions.		 * characteristics, and so it has its own functions.
 *								 *
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @return Current active register for specified slave		 * @return Current active register for specified slave
 * @see MPU6050_RA_I2C_SLV0_REG					 * @see MPU6050_RA_I2C_SLV0_REG
 */								 */
uint8_t MPU6050_getSlaveRegister(uint8_t num)		      |	uint8_t MPU6050_getSlaveRegister(uint8_t num) {
{							      |	    if (num > 3) return 0;
	if (num > 3) return 0;				      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_REG 
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ |	    return mpu6050.buffer[0];
	                mpu6050.buffer);		      <
	return mpu6050.buffer[0];			      <
}								}
/** Set the active internal register for the specified slave 	/** Set the active internal register for the specified slave 
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param reg New active register for specified slave		 * @param reg New active register for specified slave
 * @see getSlaveRegister()					 * @see getSlaveRegister()
 * @see MPU6050_RA_I2C_SLV0_REG					 * @see MPU6050_RA_I2C_SLV0_REG
 */								 */
void MPU6050_setSlaveRegister(uint8_t num, uint8_t reg)	      |	void MPU6050_setSlaveRegister(uint8_t num, uint8_t reg) {
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_REG
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0 <
}								}
/** Get the enabled value for the specified slave (0-3).	/** Get the enabled value for the specified slave (0-3).
 * When set to 1, this bit enables Slave 0 for data transfer 	 * When set to 1, this bit enables Slave 0 for data transfer 
 * cleared to 0, this bit disables Slave 0 from data transfer	 * cleared to 0, this bit disables Slave 0 from data transfer
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @return Current enabled value for specified slave		 * @return Current enabled value for specified slave
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
bool MPU6050_getSlaveEnabled(uint8_t num)		      |	bool MPU6050_getSlaveEnabled(uint8_t num) {
{							      |	    if (num > 3) return 0;
	if (num > 3) return 0;				      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_C |	    return mpu6050.buffer[0];
	               MPU6050_I2C_SLV_EN_BIT, mpu6050.buffer <
	return mpu6050.buffer[0];			      <
}								}
/** Set the enabled value for the specified slave (0-3).	/** Set the enabled value for the specified slave (0-3).
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param enabled New enabled value for specified slave		 * @param enabled New enabled value for specified slave
 * @see getSlaveEnabled()					 * @see getSlaveEnabled()
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
void MPU6050_setSlaveEnabled(uint8_t num, bool enabled)	      |	void MPU6050_setSlaveEnabled(uint8_t num, bool enabled) {
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ <
	                MPU6050_I2C_SLV_EN_BIT, enabled);     <
}								}
/** Get word pair byte-swapping enabled for the specified sla	/** Get word pair byte-swapping enabled for the specified sla
 * When set to 1, this bit enables byte swapping. When byte s	 * When set to 1, this bit enables byte swapping. When byte s
 * the high and low bytes of a word pair are swapped. Please 	 * the high and low bytes of a word pair are swapped. Please 
 * I2C_SLV0_GRP for the pairing convention of the word pairs.	 * I2C_SLV0_GRP for the pairing convention of the word pairs.
 * bytes transferred to and from Slave 0 will be written to E	 * bytes transferred to and from Slave 0 will be written to E
 * registers in the order they were transferred.		 * registers in the order they were transferred.
 *								 *
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @return Current word pair byte-swapping enabled value for 	 * @return Current word pair byte-swapping enabled value for 
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
bool MPU6050_getSlaveWordByteSwap(uint8_t num)		      |	bool MPU6050_getSlaveWordByteSwap(uint8_t num) {
{							      |	    if (num > 3) return 0;
	if (num > 3) return 0;				      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_C |	    return mpu6050.buffer[0];
	               MPU6050_I2C_SLV_BYTE_SW_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Set word pair byte-swapping enabled for the specified sla	/** Set word pair byte-swapping enabled for the specified sla
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param enabled New word pair byte-swapping enabled value f	 * @param enabled New word pair byte-swapping enabled value f
 * @see getSlaveWordByteSwap()					 * @see getSlaveWordByteSwap()
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
void MPU6050_setSlaveWordByteSwap(uint8_t num, bool enabled)  |	void MPU6050_setSlaveWordByteSwap(uint8_t num, bool enabled) 
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ <
	                MPU6050_I2C_SLV_BYTE_SW_BIT, enabled) <
}								}
/** Get write mode for the specified slave (0-3).		/** Get write mode for the specified slave (0-3).
 * When set to 1, the transaction will read or write data onl	 * When set to 1, the transaction will read or write data onl
 * 0, the transaction will write a register address prior to 	 * 0, the transaction will write a register address prior to 
 * data. This should equal 0 when specifying the register add	 * data. This should equal 0 when specifying the register add
 * Slave device to/from which the ensuing data transaction wi	 * Slave device to/from which the ensuing data transaction wi
 *								 *
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @return Current write mode for specified slave (0 = regist	 * @return Current write mode for specified slave (0 = regist
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
bool MPU6050_getSlaveWriteMode(uint8_t num)		      |	bool MPU6050_getSlaveWriteMode(uint8_t num) {
{							      |	    if (num > 3) return 0;
	if (num > 3) return 0;				      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_C |	    return mpu6050.buffer[0];
	               MPU6050_I2C_SLV_REG_DIS_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Set write mode for the specified slave (0-3).		/** Set write mode for the specified slave (0-3).
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param mode New write mode for specified slave (0 = regist	 * @param mode New write mode for specified slave (0 = regist
 * @see getSlaveWriteMode()					 * @see getSlaveWriteMode()
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
void MPU6050_setSlaveWriteMode(uint8_t num, bool mode)	      |	void MPU6050_setSlaveWriteMode(uint8_t num, bool mode) {
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ <
	                MPU6050_I2C_SLV_REG_DIS_BIT, mode);   <
}								}
/** Get word pair grouping order offset for the specified sla	/** Get word pair grouping order offset for the specified sla
 * This sets specifies the grouping order of word pairs recei	 * This sets specifies the grouping order of word pairs recei
 * When cleared to 0, bytes from register addresses 0 and 1, 	 * When cleared to 0, bytes from register addresses 0 and 1, 
 * then odd register addresses) are paired to form a word. Wh	 * then odd register addresses) are paired to form a word. Wh
 * from register addresses are paired 1 and 2, 3 and 4, etc. 	 * from register addresses are paired 1 and 2, 3 and 4, etc. 
 * register addresses) are paired to form a word.		 * register addresses) are paired to form a word.
 *								 *
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @return Current word pair grouping order offset for specif	 * @return Current word pair grouping order offset for specif
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
bool MPU6050_getSlaveWordGroupOffset(uint8_t num)	      |	bool MPU6050_getSlaveWordGroupOffset(uint8_t num) {
{							      |	    if (num > 3) return 0;
	if (num > 3) return 0;				      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL 
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_C |	    return mpu6050.buffer[0];
	               MPU6050_I2C_SLV_GRP_BIT, mpu6050.buffe <
	return mpu6050.buffer[0];			      <
}								}
/** Set word pair grouping order offset for the specified sla	/** Set word pair grouping order offset for the specified sla
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param enabled New word pair grouping order offset for spe	 * @param enabled New word pair grouping order offset for spe
 * @see getSlaveWordGroupOffset()				 * @see getSlaveWordGroupOffset()
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
void MPU6050_setSlaveWordGroupOffset(uint8_t num, bool enable |	void MPU6050_setSlaveWordGroupOffset(uint8_t num, bool enable
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ <
	                MPU6050_I2C_SLV_GRP_BIT, enabled);    <
}								}
/** Get number of bytes to read for the specified slave (0-3)	/** Get number of bytes to read for the specified slave (0-3)
 * Specifies the number of bytes transferred to and from Slav	 * Specifies the number of bytes transferred to and from Slav
 * bit to 0 is equivalent to disabling the register by writin	 * bit to 0 is equivalent to disabling the register by writin
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @return Number of bytes to read for specified slave		 * @return Number of bytes to read for specified slave
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
uint8_t MPU6050_getSlaveDataLength(uint8_t num)		      |	uint8_t MPU6050_getSlaveDataLength(uint8_t num) {
{							      |	    if (num > 3) return 0;
	if (num > 3) return 0;				      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTRL
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_ |	    return mpu6050.buffer[0];
	                MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C_ <
	return mpu6050.buffer[0];			      <
}								}
/** Set number of bytes to read for the specified slave (0-3)	/** Set number of bytes to read for the specified slave (0-3)
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param length Number of bytes to read for specified slave	 * @param length Number of bytes to read for specified slave
 * @see getSlaveDataLength()					 * @see getSlaveDataLength()
 * @see MPU6050_RA_I2C_SLV0_CTRL				 * @see MPU6050_RA_I2C_SLV0_CTRL
 */								 */
void MPU6050_setSlaveDataLength(uint8_t num, uint8_t length)  |	void MPU6050_setSlaveDataLength(uint8_t num, uint8_t length) 
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_CTR
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV0 <
	                 MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C <
}								}

// I2C_SLV* registers (Slave 4)					// I2C_SLV* registers (Slave 4)

/** Get the I2C address of Slave 4.				/** Get the I2C address of Slave 4.
 * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 i	 * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 i
 * operation, and if it is cleared, then it's a write operati	 * operation, and if it is cleared, then it's a write operati
 * bits (6-0) are the 7-bit device address of the slave devic	 * bits (6-0) are the 7-bit device address of the slave devic
 *								 *
 * @return Current address for Slave 4				 * @return Current address for Slave 4
 * @see getSlaveAddress()					 * @see getSlaveAddress()
 * @see MPU6050_RA_I2C_SLV4_ADDR				 * @see MPU6050_RA_I2C_SLV4_ADDR
 */								 */
uint8_t MPU6050_getSlave4Address()			      |	uint8_t MPU6050_getSlave4Address() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ADDR
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set the I2C address of Slave 4.				/** Set the I2C address of Slave 4.
 * @param address New address for Slave 4			 * @param address New address for Slave 4
 * @see getSlave4Address()					 * @see getSlave4Address()
 * @see MPU6050_RA_I2C_SLV4_ADDR				 * @see MPU6050_RA_I2C_SLV4_ADDR
 */								 */
void MPU6050_setSlave4Address(uint8_t address)		      |	void MPU6050_setSlave4Address(uint8_t address) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ADD
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4 <
}								}
/** Get the active internal register for the Slave 4.		/** Get the active internal register for the Slave 4.
 * Read/write operations for this slave will be done to whate	 * Read/write operations for this slave will be done to whate
 * register address is stored in this MPU register.		 * register address is stored in this MPU register.
 *								 *
 * @return Current active register for Slave 4			 * @return Current active register for Slave 4
 * @see MPU6050_RA_I2C_SLV4_REG					 * @see MPU6050_RA_I2C_SLV4_REG
 */								 */
uint8_t MPU6050_getSlave4Register()			      |	uint8_t MPU6050_getSlave4Register() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_REG,
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set the active internal register for Slave 4.		/** Set the active internal register for Slave 4.
 * @param reg New active register for Slave 4			 * @param reg New active register for Slave 4
 * @see getSlave4Register()					 * @see getSlave4Register()
 * @see MPU6050_RA_I2C_SLV4_REG					 * @see MPU6050_RA_I2C_SLV4_REG
 */								 */
void MPU6050_setSlave4Register(uint8_t reg)		      |	void MPU6050_setSlave4Register(uint8_t reg) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_REG
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4 <
}								}
/** Set new byte to write to Slave 4.				/** Set new byte to write to Slave 4.
 * This register stores the data to be written into the Slave	 * This register stores the data to be written into the Slave
 * is set 1 (set to read), this register has no effect.		 * is set 1 (set to read), this register has no effect.
 * @param data New byte to write to Slave 4			 * @param data New byte to write to Slave 4
 * @see MPU6050_RA_I2C_SLV4_DO					 * @see MPU6050_RA_I2C_SLV4_DO
 */								 */
void MPU6050_setSlave4OutputByte(uint8_t data)		      |	void MPU6050_setSlave4OutputByte(uint8_t data) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_DO,
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4 <
}								}
/** Get the enabled value for the Slave 4.			/** Get the enabled value for the Slave 4.
 * When set to 1, this bit enables Slave 4 for data transfer 	 * When set to 1, this bit enables Slave 4 for data transfer 
 * cleared to 0, this bit disables Slave 4 from data transfer	 * cleared to 0, this bit disables Slave 4 from data transfer
 * @return Current enabled value for Slave 4			 * @return Current enabled value for Slave 4
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
bool MPU6050_getSlave4Enabled()				      |	bool MPU6050_getSlave4Enabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTRL,
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_C |	    return mpu6050.buffer[0];
	               MPU6050_I2C_SLV4_EN_BIT, mpu6050.buffe <
	return mpu6050.buffer[0];			      <
}								}
/** Set the enabled value for Slave 4.				/** Set the enabled value for Slave 4.
 * @param enabled New enabled value for Slave 4			 * @param enabled New enabled value for Slave 4
 * @see getSlave4Enabled()					 * @see getSlave4Enabled()
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
void MPU6050_setSlave4Enabled(bool enabled)		      |	void MPU6050_setSlave4Enabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTRL
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ <
	                MPU6050_I2C_SLV4_EN_BIT, enabled);    <
}								}
/** Get the enabled value for Slave 4 transaction interrupts.	/** Get the enabled value for Slave 4 transaction interrupts.
 * When set to 1, this bit enables the generation of an inter	 * When set to 1, this bit enables the generation of an inter
 * completion of a Slave 4 transaction. When cleared to 0, th	 * completion of a Slave 4 transaction. When cleared to 0, th
 * generation of an interrupt signal upon completion of a Sla	 * generation of an interrupt signal upon completion of a Sla
 * The interrupt status can be observed in Register 54.		 * The interrupt status can be observed in Register 54.
 *								 *
 * @return Current enabled value for Slave 4 transaction inte	 * @return Current enabled value for Slave 4 transaction inte
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
bool MPU6050_getSlave4InterruptEnabled()		      |	bool MPU6050_getSlave4InterruptEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTRL,
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_C |	    return mpu6050.buffer[0];
	               MPU6050_I2C_SLV4_INT_EN_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Set the enabled value for Slave 4 transaction interrupts.	/** Set the enabled value for Slave 4 transaction interrupts.
 * @param enabled New enabled value for Slave 4 transaction i	 * @param enabled New enabled value for Slave 4 transaction i
 * @see getSlave4InterruptEnabled()				 * @see getSlave4InterruptEnabled()
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
void MPU6050_setSlave4InterruptEnabled(bool enabled)	      |	void MPU6050_setSlave4InterruptEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTRL
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ <
	                MPU6050_I2C_SLV4_INT_EN_BIT, enabled) <
}								}
/** Get write mode for Slave 4.					/** Get write mode for Slave 4.
 * When set to 1, the transaction will read or write data onl	 * When set to 1, the transaction will read or write data onl
 * 0, the transaction will write a register address prior to 	 * 0, the transaction will write a register address prior to 
 * data. This should equal 0 when specifying the register add	 * data. This should equal 0 when specifying the register add
 * Slave device to/from which the ensuing data transaction wi	 * Slave device to/from which the ensuing data transaction wi
 *								 *
 * @return Current write mode for Slave 4 (0 = register addre	 * @return Current write mode for Slave 4 (0 = register addre
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
bool MPU6050_getSlave4WriteMode()			      |	bool MPU6050_getSlave4WriteMode() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTRL,
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_C |	    return mpu6050.buffer[0];
	               MPU6050_I2C_SLV4_REG_DIS_BIT, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}
/** Set write mode for the Slave 4.				/** Set write mode for the Slave 4.
 * @param mode New write mode for Slave 4 (0 = register addre	 * @param mode New write mode for Slave 4 (0 = register addre
 * @see getSlave4WriteMode()					 * @see getSlave4WriteMode()
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
void MPU6050_setSlave4WriteMode(bool mode)		      |	void MPU6050_setSlave4WriteMode(bool mode) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTRL
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ <
	                MPU6050_I2C_SLV4_REG_DIS_BIT, mode);  <
}								}
/** Get Slave 4 master delay value.				/** Get Slave 4 master delay value.
 * This configures the reduced access rate of I2C slaves rela	 * This configures the reduced access rate of I2C slaves rela
 * Rate. When a slave's access rate is decreased relative to 	 * Rate. When a slave's access rate is decreased relative to 
 * the slave is accessed every:					 * the slave is accessed every:
 *								 *
 *     1 / (1 + I2C_MST_DLY) samples				 *     1 / (1 + I2C_MST_DLY) samples
 *								 *
 * This base Sample Rate in turn is determined by SMPLRT_DIV 	 * This base Sample Rate in turn is determined by SMPLRT_DIV 
 * DLPF_CFG (register 26). Whether a slave's access rate is r	 * DLPF_CFG (register 26). Whether a slave's access rate is r
 * the Sample Rate is determined by I2C_MST_DELAY_CTRL (regis	 * the Sample Rate is determined by I2C_MST_DELAY_CTRL (regis
 * further information regarding the Sample Rate, please refe	 * further information regarding the Sample Rate, please refe
 *								 *
 * @return Current Slave 4 master delay value			 * @return Current Slave 4 master delay value
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
uint8_t MPU6050_getSlave4MasterDelay()			      |	uint8_t MPU6050_getSlave4MasterDelay() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTRL
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ |	    return mpu6050.buffer[0];
	                MPU6050_I2C_SLV4_MST_DLY_BIT, MPU6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Set Slave 4 master delay value.				/** Set Slave 4 master delay value.
 * @param delay New Slave 4 master delay value			 * @param delay New Slave 4 master delay value
 * @see getSlave4MasterDelay()					 * @see getSlave4MasterDelay()
 * @see MPU6050_RA_I2C_SLV4_CTRL				 * @see MPU6050_RA_I2C_SLV4_CTRL
 */								 */
void MPU6050_setSlave4MasterDelay(uint8_t delay)	      |	void MPU6050_setSlave4MasterDelay(uint8_t delay) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_CTR
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_I2C_SLV4 <
	                 MPU6050_I2C_SLV4_MST_DLY_BIT, MPU605 <
}								}
/** Get last available byte read from Slave 4.			/** Get last available byte read from Slave 4.
 * This register stores the data read from Slave 4. This fiel	 * This register stores the data read from Slave 4. This fiel
 * after a read transaction.					 * after a read transaction.
 * @return Last available byte read from to Slave 4		 * @return Last available byte read from to Slave 4
 * @see MPU6050_RA_I2C_SLV4_DI					 * @see MPU6050_RA_I2C_SLV4_DI
 */								 */
uint8_t MPU6050_getSlate4InputByte()			      |	uint8_t MPU6050_getSlate4InputByte() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_DI, 
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV4_ |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}

// I2C_MST_STATUS register					// I2C_MST_STATUS register

/** Get FSYNC interrupt status.					/** Get FSYNC interrupt status.
 * This bit reflects the status of the FSYNC interrupt from a	 * This bit reflects the status of the FSYNC interrupt from a
 * into the MPU-60X0. This is used as a way to pass an extern	 * into the MPU-60X0. This is used as a way to pass an extern
 * through the MPU-60X0 to the host application processor. Wh	 * through the MPU-60X0 to the host application processor. Wh
 * bit will cause an interrupt if FSYNC_INT_EN is asserted in	 * bit will cause an interrupt if FSYNC_INT_EN is asserted in
 * (Register 55).						 * (Register 55).
 * @return FSYNC interrupt status				 * @return FSYNC interrupt status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getPassthroughStatus()			      |	bool MPU6050_getPassthroughStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_PASS_THROUGH_BIT, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}
/** Get Slave 4 transaction done status.			/** Get Slave 4 transaction done status.
 * Automatically sets to 1 when a Slave 4 transaction has com	 * Automatically sets to 1 when a Slave 4 transaction has com
 * triggers an interrupt if the I2C_MST_INT_EN bit in the INT	 * triggers an interrupt if the I2C_MST_INT_EN bit in the INT
 * (Register 56) is asserted and if the SLV_4_DONE_INT bit is	 * (Register 56) is asserted and if the SLV_4_DONE_INT bit is
 * I2C_SLV4_CTRL register (Register 52).			 * I2C_SLV4_CTRL register (Register 52).
 * @return Slave 4 transaction done status			 * @return Slave 4 transaction done status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getSlave4IsDone()				      |	bool MPU6050_getSlave4IsDone() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_I2C_SLV4_DONE_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Get master arbitration lost status.				/** Get master arbitration lost status.
 * This bit automatically sets to 1 when the I2C Master has l	 * This bit automatically sets to 1 when the I2C Master has l
 * the auxiliary I2C bus (an error condition). This triggers 	 * the auxiliary I2C bus (an error condition). This triggers 
 * I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56	 * I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56
 * @return Master arbitration lost status			 * @return Master arbitration lost status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getLostArbitration()			      |	bool MPU6050_getLostArbitration() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_I2C_LOST_ARB_BIT, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}
/** Get Slave 4 NACK status.					/** Get Slave 4 NACK status.
 * This bit automatically sets to 1 when the I2C Master recei	 * This bit automatically sets to 1 when the I2C Master recei
 * transaction with Slave 4. This triggers an interrupt if th	 * transaction with Slave 4. This triggers an interrupt if th
 * bit in the INT_ENABLE register (Register 56) is asserted.	 * bit in the INT_ENABLE register (Register 56) is asserted.
 * @return Slave 4 NACK interrupt status			 * @return Slave 4 NACK interrupt status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getSlave4Nack()				      |	bool MPU6050_getSlave4Nack() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_I2C_SLV4_NACK_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Get Slave 3 NACK status.					/** Get Slave 3 NACK status.
 * This bit automatically sets to 1 when the I2C Master recei	 * This bit automatically sets to 1 when the I2C Master recei
 * transaction with Slave 3. This triggers an interrupt if th	 * transaction with Slave 3. This triggers an interrupt if th
 * bit in the INT_ENABLE register (Register 56) is asserted.	 * bit in the INT_ENABLE register (Register 56) is asserted.
 * @return Slave 3 NACK interrupt status			 * @return Slave 3 NACK interrupt status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getSlave3Nack()				      |	bool MPU6050_getSlave3Nack() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_I2C_SLV3_NACK_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Get Slave 2 NACK status.					/** Get Slave 2 NACK status.
 * This bit automatically sets to 1 when the I2C Master recei	 * This bit automatically sets to 1 when the I2C Master recei
 * transaction with Slave 2. This triggers an interrupt if th	 * transaction with Slave 2. This triggers an interrupt if th
 * bit in the INT_ENABLE register (Register 56) is asserted.	 * bit in the INT_ENABLE register (Register 56) is asserted.
 * @return Slave 2 NACK interrupt status			 * @return Slave 2 NACK interrupt status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getSlave2Nack()				      |	bool MPU6050_getSlave2Nack() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_I2C_SLV2_NACK_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Get Slave 1 NACK status.					/** Get Slave 1 NACK status.
 * This bit automatically sets to 1 when the I2C Master recei	 * This bit automatically sets to 1 when the I2C Master recei
 * transaction with Slave 1. This triggers an interrupt if th	 * transaction with Slave 1. This triggers an interrupt if th
 * bit in the INT_ENABLE register (Register 56) is asserted.	 * bit in the INT_ENABLE register (Register 56) is asserted.
 * @return Slave 1 NACK interrupt status			 * @return Slave 1 NACK interrupt status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getSlave1Nack()				      |	bool MPU6050_getSlave1Nack() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_I2C_SLV1_NACK_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Get Slave 0 NACK status.					/** Get Slave 0 NACK status.
 * This bit automatically sets to 1 when the I2C Master recei	 * This bit automatically sets to 1 when the I2C Master recei
 * transaction with Slave 0. This triggers an interrupt if th	 * transaction with Slave 0. This triggers an interrupt if th
 * bit in the INT_ENABLE register (Register 56) is asserted.	 * bit in the INT_ENABLE register (Register 56) is asserted.
 * @return Slave 0 NACK interrupt status			 * @return Slave 0 NACK interrupt status
 * @see MPU6050_RA_I2C_MST_STATUS				 * @see MPU6050_RA_I2C_MST_STATUS
 */								 */
bool MPU6050_getSlave0Nack()				      |	bool MPU6050_getSlave0Nack() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_ST |	    return mpu6050.buffer[0];
	               MPU6050_MST_I2C_SLV0_NACK_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}								}

// INT_PIN_CFG register						// INT_PIN_CFG register

/** Get interrupt logic level mode.				/** Get interrupt logic level mode.
 * Will be set 0 for active-high, 1 for active-low.		 * Will be set 0 for active-high, 1 for active-low.
 * @return Current interrupt mode (0=active-high, 1=active-lo	 * @return Current interrupt mode (0=active-high, 1=active-lo
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_INT_LEVEL_BIT				 * @see MPU6050_INTCFG_INT_LEVEL_BIT
 */								 */
bool MPU6050_getInterruptMode()				      |	bool MPU6050_getInterruptMode() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_INT_LEVEL_BIT, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}
/** Set interrupt logic level mode.				/** Set interrupt logic level mode.
 * @param mode New interrupt mode (0=active-high, 1=active-lo	 * @param mode New interrupt mode (0=active-high, 1=active-lo
 * @see getInterruptMode()					 * @see getInterruptMode()
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_INT_LEVEL_BIT				 * @see MPU6050_INTCFG_INT_LEVEL_BIT
 */								 */
void MPU6050_setInterruptMode(bool mode)		      |	void MPU6050_setInterruptMode(bool mode) {
{							      |	   I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_INT_LEVEL_BIT, mode);  <
}								}
/** Get interrupt drive mode.					/** Get interrupt drive mode.
 * Will be set 0 for push-pull, 1 for open-drain.		 * Will be set 0 for push-pull, 1 for open-drain.
 * @return Current interrupt drive mode (0=push-pull, 1=open-	 * @return Current interrupt drive mode (0=push-pull, 1=open-
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_INT_OPEN_BIT				 * @see MPU6050_INTCFG_INT_OPEN_BIT
 */								 */
bool MPU6050_getInterruptDrive()			      |	bool MPU6050_getInterruptDrive() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_INT_OPEN_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Set interrupt drive mode.					/** Set interrupt drive mode.
 * @param drive New interrupt drive mode (0=push-pull, 1=open	 * @param drive New interrupt drive mode (0=push-pull, 1=open
 * @see getInterruptDrive()					 * @see getInterruptDrive()
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_INT_OPEN_BIT				 * @see MPU6050_INTCFG_INT_OPEN_BIT
 */								 */
void MPU6050_setInterruptDrive(bool drive)		      |	void MPU6050_setInterruptDrive(bool drive) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, 
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_INT_OPEN_BIT, drive);  <
}								}
/** Get interrupt latch mode.					/** Get interrupt latch mode.
 * Will be set 0 for 50us-pulse, 1 for latch-until-int-cleare	 * Will be set 0 for 50us-pulse, 1 for latch-until-int-cleare
 * @return Current latch mode (0=50us-pulse, 1=latch-until-in	 * @return Current latch mode (0=50us-pulse, 1=latch-until-in
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_LATCH_INT_EN_BIT				 * @see MPU6050_INTCFG_LATCH_INT_EN_BIT
 */								 */
bool MPU6050_getInterruptLatch()			      |	bool MPU6050_getInterruptLatch() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_LATCH_INT_EN_BIT, mpu60 <
	return mpu6050.buffer[0];			      <
}								}
/** Set interrupt latch mode.					/** Set interrupt latch mode.
 * @param latch New latch mode (0=50us-pulse, 1=latch-until-i	 * @param latch New latch mode (0=50us-pulse, 1=latch-until-i
 * @see getInterruptLatch()					 * @see getInterruptLatch()
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_LATCH_INT_EN_BIT				 * @see MPU6050_INTCFG_LATCH_INT_EN_BIT
 */								 */
void MPU6050_setInterruptLatch(bool latch)		      |	void MPU6050_setInterruptLatch(bool latch) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, 
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_LATCH_INT_EN_BIT, latc <
}								}
/** Get interrupt latch clear mode.				/** Get interrupt latch clear mode.
 * Will be set 0 for status-read-only, 1 for any-register-rea	 * Will be set 0 for status-read-only, 1 for any-register-rea
 * @return Current latch clear mode (0=status-read-only, 1=an	 * @return Current latch clear mode (0=status-read-only, 1=an
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT				 * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT
 */								 */
bool MPU6050_getInterruptLatchClear()			      |	bool MPU6050_getInterruptLatchClear() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_INT_RD_CLEAR_BIT, mpu60 <
	return mpu6050.buffer[0];			      <
}								}
/** Set interrupt latch clear mode.				/** Set interrupt latch clear mode.
 * @param clear New latch clear mode (0=status-read-only, 1=a	 * @param clear New latch clear mode (0=status-read-only, 1=a
 * @see getInterruptLatchClear()				 * @see getInterruptLatchClear()
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT				 * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT
 */								 */
void MPU6050_setInterruptLatchClear(bool clear)		      |	void MPU6050_setInterruptLatchClear(bool clear) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, 
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_INT_RD_CLEAR_BIT, clea <
}								}
/** Get FSYNC interrupt logic level mode.			/** Get FSYNC interrupt logic level mode.
 * @return Current FSYNC interrupt mode (0=active-high, 1=act	 * @return Current FSYNC interrupt mode (0=active-high, 1=act
 * @see getFSyncInterruptMode()					 * @see getFSyncInterruptMode()
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT			 * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT
 */								 */
bool MPU6050_getFSyncInterruptLevel()			      |	bool MPU6050_getFSyncInterruptLevel() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, mp <
	return mpu6050.buffer[0];			      <
}								}
/** Set FSYNC interrupt logic level mode.			/** Set FSYNC interrupt logic level mode.
 * @param mode New FSYNC interrupt mode (0=active-high, 1=act	 * @param mode New FSYNC interrupt mode (0=active-high, 1=act
 * @see getFSyncInterruptMode()					 * @see getFSyncInterruptMode()
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT			 * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT
 */								 */
void MPU6050_setFSyncInterruptLevel(bool level)		      |	void MPU6050_setFSyncInterruptLevel(bool level) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, 
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, l <
}								}
/** Get FSYNC pin interrupt enabled setting.			/** Get FSYNC pin interrupt enabled setting.
 * Will be set 0 for disabled, 1 for enabled.			 * Will be set 0 for disabled, 1 for enabled.
 * @return Current interrupt enabled setting			 * @return Current interrupt enabled setting
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT				 * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT
 */								 */
bool MPU6050_getFSyncInterruptEnabled()			      |	bool MPU6050_getFSyncInterruptEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_FSYNC_INT_EN_BIT, mpu60 <
	return mpu6050.buffer[0];			      <
}								}
/** Set FSYNC pin interrupt enabled setting.			/** Set FSYNC pin interrupt enabled setting.
 * @param enabled New FSYNC pin interrupt enabled setting	 * @param enabled New FSYNC pin interrupt enabled setting
 * @see getFSyncInterruptEnabled()				 * @see getFSyncInterruptEnabled()
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT				 * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT
 */								 */
void MPU6050_setFSyncInterruptEnabled(bool enabled)	      |	void MPU6050_setFSyncInterruptEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, 
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_FSYNC_INT_EN_BIT, enab <
}								}
/** Get I2C bypass enabled status.				/** Get I2C bypass enabled status.
 * When this bit is equal to 1 and I2C_MST_EN (Register 106 b	 * When this bit is equal to 1 and I2C_MST_EN (Register 106 b
 * 0, the host application processor will be able to directly	 * 0, the host application processor will be able to directly
 * auxiliary I2C bus of the MPU-60X0. When this bit is equal 	 * auxiliary I2C bus of the MPU-60X0. When this bit is equal 
 * application processor will not be able to directly access 	 * application processor will not be able to directly access 
 * bus of the MPU-60X0 regardless of the state of I2C_MST_EN 	 * bus of the MPU-60X0 regardless of the state of I2C_MST_EN 
 * bit[5]).							 * bit[5]).
 * @return Current I2C bypass enabled status			 * @return Current I2C bypass enabled status
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT			 * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT
 */								 */
bool MPU6050_getI2CBypassEnabled()			      |	bool MPU6050_getI2CBypassEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_I2C_BYPASS_EN_BIT, mpu6 <
	return mpu6050.buffer[0];			      <
}								}
/** Set I2C bypass enabled status.				/** Set I2C bypass enabled status.
 * When this bit is equal to 1 and I2C_MST_EN (Register 106 b	 * When this bit is equal to 1 and I2C_MST_EN (Register 106 b
 * 0, the host application processor will be able to directly	 * 0, the host application processor will be able to directly
 * auxiliary I2C bus of the MPU-60X0. When this bit is equal 	 * auxiliary I2C bus of the MPU-60X0. When this bit is equal 
 * application processor will not be able to directly access 	 * application processor will not be able to directly access 
 * bus of the MPU-60X0 regardless of the state of I2C_MST_EN 	 * bus of the MPU-60X0 regardless of the state of I2C_MST_EN 
 * bit[5]).							 * bit[5]).
 * @param enabled New I2C bypass enabled status			 * @param enabled New I2C bypass enabled status
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT			 * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT
 */								 */
void MPU6050_setI2CBypassEnabled(bool enabled)		      |	void MPU6050_setI2CBypassEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, 
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_I2C_BYPASS_EN_BIT, ena <
}								}
/** Get reference clock output enabled status.			/** Get reference clock output enabled status.
 * When this bit is equal to 1, a reference clock output is p	 * When this bit is equal to 1, a reference clock output is p
 * CLKOUT pin. When this bit is equal to 0, the clock output 	 * CLKOUT pin. When this bit is equal to 0, the clock output 
 * further information regarding CLKOUT, please refer to the 	 * further information regarding CLKOUT, please refer to the 
 * Specification document.					 * Specification document.
 * @return Current reference clock output enabled status	 * @return Current reference clock output enabled status
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_CLKOUT_EN_BIT				 * @see MPU6050_INTCFG_CLKOUT_EN_BIT
 */								 */
bool MPU6050_getClockOutputEnabled()			      |	bool MPU6050_getClockOutputEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CF |	    return mpu6050.buffer[0];
	               MPU6050_INTCFG_CLKOUT_EN_BIT, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}
/** Set reference clock output enabled status.			/** Set reference clock output enabled status.
 * When this bit is equal to 1, a reference clock output is p	 * When this bit is equal to 1, a reference clock output is p
 * CLKOUT pin. When this bit is equal to 0, the clock output 	 * CLKOUT pin. When this bit is equal to 0, the clock output 
 * further information regarding CLKOUT, please refer to the 	 * further information regarding CLKOUT, please refer to the 
 * Specification document.					 * Specification document.
 * @param enabled New reference clock output enabled status	 * @param enabled New reference clock output enabled status
 * @see MPU6050_RA_INT_PIN_CFG					 * @see MPU6050_RA_INT_PIN_CFG
 * @see MPU6050_INTCFG_CLKOUT_EN_BIT				 * @see MPU6050_INTCFG_CLKOUT_EN_BIT
 */								 */
void MPU6050_setClockOutputEnabled(bool enabled)	      |	void MPU6050_setClockOutputEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_CFG, 
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_PIN_C <
	                MPU6050_INTCFG_CLKOUT_EN_BIT, enabled <
}								}

// INT_ENABLE register						// INT_ENABLE register

/** Get full interrupt enabled status.				/** Get full interrupt enabled status.
 * Full register byte for all interrupts, for quick reading. 	 * Full register byte for all interrupts, for quick reading. 
 * set 0 for disabled, 1 for enabled.				 * set 0 for disabled, 1 for enabled.
 * @return Current interrupt enabled status			 * @return Current interrupt enabled status
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_FF_BIT				 * @see MPU6050_INTERRUPT_FF_BIT
 **/								 **/
uint8_t MPU6050_getIntEnabled()				      |	uint8_t MPU6050_getIntEnabled() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, m
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_INT_ENABL |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Set full interrupt enabled status.				/** Set full interrupt enabled status.
 * Full register byte for all interrupts, for quick reading. 	 * Full register byte for all interrupts, for quick reading. 
 * set 0 for disabled, 1 for enabled.				 * set 0 for disabled, 1 for enabled.
 * @param enabled New interrupt enabled status			 * @param enabled New interrupt enabled status
 * @see getIntFreefallEnabled()					 * @see getIntFreefallEnabled()
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_FF_BIT				 * @see MPU6050_INTERRUPT_FF_BIT
 **/								 **/
void MPU6050_setIntEnabled(uint8_t enabled)		      |	void MPU6050_setIntEnabled(uint8_t enabled) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, 
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_INT_ENAB <
}								}
/** Get Free Fall interrupt enabled status.			/** Get Free Fall interrupt enabled status.
 * Will be set 0 for disabled, 1 for enabled.			 * Will be set 0 for disabled, 1 for enabled.
 * @return Current interrupt enabled status			 * @return Current interrupt enabled status
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_FF_BIT				 * @see MPU6050_INTERRUPT_FF_BIT
 **/								 **/
bool MPU6050_getIntFreefallEnabled()			      |	bool MPU6050_getIntFreefallEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Free Fall interrupt enabled status.			/** Set Free Fall interrupt enabled status.
 * @param enabled New interrupt enabled status			 * @param enabled New interrupt enabled status
 * @see getIntFreefallEnabled()					 * @see getIntFreefallEnabled()
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_FF_BIT				 * @see MPU6050_INTERRUPT_FF_BIT
 **/								 **/
void MPU6050_setIntFreefallEnabled(bool enabled)	      |	void MPU6050_setIntFreefallEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL <
	                MPU6050_INTERRUPT_FF_BIT, enabled);   <
}								}
/** Get Motion Detection interrupt enabled status.		/** Get Motion Detection interrupt enabled status.
 * Will be set 0 for disabled, 1 for enabled.			 * Will be set 0 for disabled, 1 for enabled.
 * @return Current interrupt enabled status			 * @return Current interrupt enabled status
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_MOT_BIT				 * @see MPU6050_INTERRUPT_MOT_BIT
 **/								 **/
bool MPU6050_getIntMotionEnabled()			      |	bool MPU6050_getIntMotionEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_MOT_BIT, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}								}
/** Set Motion Detection interrupt enabled status.		/** Set Motion Detection interrupt enabled status.
 * @param enabled New interrupt enabled status			 * @param enabled New interrupt enabled status
 * @see getIntMotionEnabled()					 * @see getIntMotionEnabled()
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_MOT_BIT				 * @see MPU6050_INTERRUPT_MOT_BIT
 **/								 **/
void MPU6050_setIntMotionEnabled(bool enabled)		      |	void MPU6050_setIntMotionEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL <
	                MPU6050_INTERRUPT_MOT_BIT, enabled);  <
}								}
/** Get Zero Motion Detection interrupt enabled status.		/** Get Zero Motion Detection interrupt enabled status.
 * Will be set 0 for disabled, 1 for enabled.			 * Will be set 0 for disabled, 1 for enabled.
 * @return Current interrupt enabled status			 * @return Current interrupt enabled status
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_ZMOT_BIT				 * @see MPU6050_INTERRUPT_ZMOT_BIT
 **/								 **/
bool MPU6050_getIntZeroMotionEnabled()			      |	bool MPU6050_getIntZeroMotionEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_ZMOT_BIT, mpu6050.bu <
	return mpu6050.buffer[0];			      <
}								}
/** Set Zero Motion Detection interrupt enabled status.		/** Set Zero Motion Detection interrupt enabled status.
 * @param enabled New interrupt enabled status			 * @param enabled New interrupt enabled status
 * @see getIntZeroMotionEnabled()				 * @see getIntZeroMotionEnabled()
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_ZMOT_BIT				 * @see MPU6050_INTERRUPT_ZMOT_BIT
 **/								 **/
void MPU6050_setIntZeroMotionEnabled(bool enabled)	      |	void MPU6050_setIntZeroMotionEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL <
	                MPU6050_INTERRUPT_ZMOT_BIT, enabled); <
}								}
/** Get FIFO Buffer Overflow interrupt enabled status.		/** Get FIFO Buffer Overflow interrupt enabled status.
 * Will be set 0 for disabled, 1 for enabled.			 * Will be set 0 for disabled, 1 for enabled.
 * @return Current interrupt enabled status			 * @return Current interrupt enabled status
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT			 * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT
 **/								 **/
bool MPU6050_getIntFIFOBufferOverflowEnabled()		      |	bool MPU6050_getIntFIFOBufferOverflowEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_FIFO_OFLOW_BIT, mpu6 <
	return mpu6050.buffer[0];			      <
}								}
/** Set FIFO Buffer Overflow interrupt enabled status.		/** Set FIFO Buffer Overflow interrupt enabled status.
 * @param enabled New interrupt enabled status			 * @param enabled New interrupt enabled status
 * @see getIntFIFOBufferOverflowEnabled()			 * @see getIntFIFOBufferOverflowEnabled()
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT			 * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT
 **/								 **/
void MPU6050_setIntFIFOBufferOverflowEnabled(bool enabled)    |	void MPU6050_setIntFIFOBufferOverflowEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL <
	                MPU6050_INTERRUPT_FIFO_OFLOW_BIT, ena <
}								}
/** Get I2C Master interrupt enabled status.			/** Get I2C Master interrupt enabled status.
 * This enables any of the I2C Master interrupt sources to ge	 * This enables any of the I2C Master interrupt sources to ge
 * interrupt. Will be set 0 for disabled, 1 for enabled.	 * interrupt. Will be set 0 for disabled, 1 for enabled.
 * @return Current interrupt enabled status			 * @return Current interrupt enabled status
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT			 * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT
 **/								 **/
bool MPU6050_getIntI2CMasterEnabled()			      |	bool MPU6050_getIntI2CMasterEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_I2C_MST_INT_BIT, mpu <
	return mpu6050.buffer[0];			      <
}								}
/** Set I2C Master interrupt enabled status.			/** Set I2C Master interrupt enabled status.
 * @param enabled New interrupt enabled status			 * @param enabled New interrupt enabled status
 * @see getIntI2CMasterEnabled()				 * @see getIntI2CMasterEnabled()
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT			 * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT
 **/								 **/
void MPU6050_setIntI2CMasterEnabled(bool enabled)	      |	void MPU6050_setIntI2CMasterEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL <
	                MPU6050_INTERRUPT_I2C_MST_INT_BIT, en <
}								}
/** Get Data Ready interrupt enabled setting.			/** Get Data Ready interrupt enabled setting.
 * This event occurs each time a write operation to all of th	 * This event occurs each time a write operation to all of th
 * has been completed. Will be set 0 for disabled, 1 for enab	 * has been completed. Will be set 0 for disabled, 1 for enab
 * @return Current interrupt enabled status			 * @return Current interrupt enabled status
 * @see MPU6050_RA_INT_ENABLE					 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_DATA_RDY_BIT				 * @see MPU6050_INTERRUPT_DATA_RDY_BIT
 */								 */
bool MPU6050_getIntDataReadyEnabled()			      |	bool MPU6050_getIntDataReadyEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_DATA_RDY_BIT, mpu605 <
	return mpu6050.buffer[0];			      <
}								}
/** Set Data Ready interrupt enabled status.			/** Set Data Ready interrupt enabled status.
 * @param enabled New interrupt enabled status			 * @param enabled New interrupt enabled status
 * @see getIntDataReadyEnabled()				 * @see getIntDataReadyEnabled()
 * @see MPU6050_RA_INT_CFG					 * @see MPU6050_RA_INT_CFG
 * @see MPU6050_INTERRUPT_DATA_RDY_BIT				 * @see MPU6050_INTERRUPT_DATA_RDY_BIT
 */								 */
void MPU6050_setIntDataReadyEnabled(bool enabled)	      |	void MPU6050_setIntDataReadyEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL <
	                MPU6050_INTERRUPT_DATA_RDY_BIT, enabl <
}								}

// INT_STATUS register						// INT_STATUS register

/** Get full set of interrupt status bits.			/** Get full set of interrupt status bits.
 * These bits clear to 0 after the register has been read. Ve	 * These bits clear to 0 after the register has been read. Ve
 * for getting multiple INT statuses, since each single bit r	 * for getting multiple INT statuses, since each single bit r
 * all of them because it has to read the whole byte.		 * all of them because it has to read the whole byte.
 * @return Current interrupt status				 * @return Current interrupt status
 * @see MPU6050_RA_INT_STATUS					 * @see MPU6050_RA_INT_STATUS
 */								 */
uint8_t MPU6050_getIntStatus()				      |	uint8_t MPU6050_getIntStatus() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_INT_STATUS, m
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_INT_STATU |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      <
}								}
/** Get Free Fall interrupt status.				/** Get Free Fall interrupt status.
 * This bit automatically sets to 1 when a Free Fall interrup	 * This bit automatically sets to 1 when a Free Fall interrup
 * generated. The bit clears to 0 after the register has been	 * generated. The bit clears to 0 after the register has been
 * @return Current interrupt status				 * @return Current interrupt status
 * @see MPU6050_RA_INT_STATUS					 * @see MPU6050_RA_INT_STATUS
 * @see MPU6050_INTERRUPT_FF_BIT				 * @see MPU6050_INTERRUPT_FF_BIT
 */								 */
bool MPU6050_getIntFreefallStatus()			      |	bool MPU6050_getIntFreefallStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Get Motion Detection interrupt status.			/** Get Motion Detection interrupt status.
 * This bit automatically sets to 1 when a Motion Detection i	 * This bit automatically sets to 1 when a Motion Detection i
 * generated. The bit clears to 0 after the register has been	 * generated. The bit clears to 0 after the register has been
 * @return Current interrupt status				 * @return Current interrupt status
 * @see MPU6050_RA_INT_STATUS					 * @see MPU6050_RA_INT_STATUS
 * @see MPU6050_INTERRUPT_MOT_BIT				 * @see MPU6050_INTERRUPT_MOT_BIT
 */								 */
bool MPU6050_getIntMotionStatus()			      |	bool MPU6050_getIntMotionStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_MOT_BIT, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}								}
/** Get Zero Motion Detection interrupt status.			/** Get Zero Motion Detection interrupt status.
 * This bit automatically sets to 1 when a Zero Motion Detect	 * This bit automatically sets to 1 when a Zero Motion Detect
 * been generated. The bit clears to 0 after the register has	 * been generated. The bit clears to 0 after the register has
 * @return Current interrupt status				 * @return Current interrupt status
 * @see MPU6050_RA_INT_STATUS					 * @see MPU6050_RA_INT_STATUS
 * @see MPU6050_INTERRUPT_ZMOT_BIT				 * @see MPU6050_INTERRUPT_ZMOT_BIT
 */								 */
bool MPU6050_getIntZeroMotionStatus()			      |	bool MPU6050_getIntZeroMotionStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_ZMOT_BIT, mpu6050.bu <
	return mpu6050.buffer[0];			      <
}								}
/** Get FIFO Buffer Overflow interrupt status.			/** Get FIFO Buffer Overflow interrupt status.
 * This bit automatically sets to 1 when a Free Fall interrup	 * This bit automatically sets to 1 when a Free Fall interrup
 * generated. The bit clears to 0 after the register has been	 * generated. The bit clears to 0 after the register has been
 * @return Current interrupt status				 * @return Current interrupt status
 * @see MPU6050_RA_INT_STATUS					 * @see MPU6050_RA_INT_STATUS
 * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT			 * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT
 */								 */
bool MPU6050_getIntFIFOBufferOverflowStatus()		      |	bool MPU6050_getIntFIFOBufferOverflowStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_FIFO_OFLOW_BIT, mpu6 <
	return mpu6050.buffer[0];			      <
}								}
/** Get I2C Master interrupt status.				/** Get I2C Master interrupt status.
 * This bit automatically sets to 1 when an I2C Master interr	 * This bit automatically sets to 1 when an I2C Master interr
 * generated. For a list of I2C Master interrupts, please ref	 * generated. For a list of I2C Master interrupts, please ref
 * The bit clears to 0 after the register has been read.	 * The bit clears to 0 after the register has been read.
 * @return Current interrupt status				 * @return Current interrupt status
 * @see MPU6050_RA_INT_STATUS					 * @see MPU6050_RA_INT_STATUS
 * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT			 * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT
 */								 */
bool MPU6050_getIntI2CMasterStatus()			      |	bool MPU6050_getIntI2CMasterStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_I2C_MST_INT_BIT, mpu <
	return mpu6050.buffer[0];			      <
}								}
/** Get Data Ready interrupt status.				/** Get Data Ready interrupt status.
 * This bit automatically sets to 1 when a Data Ready interru	 * This bit automatically sets to 1 when a Data Ready interru
 * generated. The bit clears to 0 after the register has been	 * generated. The bit clears to 0 after the register has been
 * @return Current interrupt status				 * @return Current interrupt status
 * @see MPU6050_RA_INT_STATUS					 * @see MPU6050_RA_INT_STATUS
 * @see MPU6050_INTERRUPT_DATA_RDY_BIT				 * @see MPU6050_INTERRUPT_DATA_RDY_BIT
 */								 */
bool MPU6050_getIntDataReadyStatus()			      |	bool MPU6050_getIntDataReadyStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_DATA_RDY_BIT, mpu605 <
	return mpu6050.buffer[0];			      <
}								}

// ACCEL_*OUT_* registers					// ACCEL_*OUT_* registers

/** Get raw 9-axis motion sensor readings (accel/gyro/compass	/** Get raw 9-axis motion sensor readings (accel/gyro/compass
 * FUNCTION NOT FULLY IMPLEMENTED YET.				 * FUNCTION NOT FULLY IMPLEMENTED YET.
 * @param ax 16-bit signed integer container for acceleromete	 * @param ax 16-bit signed integer container for acceleromete
 * @param ay 16-bit signed integer container for acceleromete	 * @param ay 16-bit signed integer container for acceleromete
 * @param az 16-bit signed integer container for acceleromete	 * @param az 16-bit signed integer container for acceleromete
 * @param gx 16-bit signed integer container for gyroscope X-	 * @param gx 16-bit signed integer container for gyroscope X-
 * @param gy 16-bit signed integer container for gyroscope Y-	 * @param gy 16-bit signed integer container for gyroscope Y-
 * @param gz 16-bit signed integer container for gyroscope Z-	 * @param gz 16-bit signed integer container for gyroscope Z-
 * @param mx 16-bit signed integer container for magnetometer	 * @param mx 16-bit signed integer container for magnetometer
 * @param my 16-bit signed integer container for magnetometer	 * @param my 16-bit signed integer container for magnetometer
 * @param mz 16-bit signed integer container for magnetometer	 * @param mz 16-bit signed integer container for magnetometer
 * @see getMotion6()						 * @see getMotion6()
 * @see getAcceleration()					 * @see getAcceleration()
 * @see getRotation()						 * @see getRotation()
 * @see MPU6050_RA_ACCEL_XOUT_H					 * @see MPU6050_RA_ACCEL_XOUT_H
 */								 */
void MPU6050_getMotion9(int16_t *ax, int16_t *ay, int16_t *az |	void MPU6050_getMotion9(int16_t* ax, int16_t* ay, int16_t* az
                        int16_t *gy, int16_t *gz, int16_t *mx |	    MPU6050_getMotion6(ax, ay, az, gx, gy, gz);
{							      |	    // TODO: magnetometer integration
	MPU6050_getMotion6(ax, ay, az, gx, gy, gz);	      <
	// TODO: magnetometer integration		      <
}								}
/** Get raw 6-axis motion sensor readings (accel/gyro).		/** Get raw 6-axis motion sensor readings (accel/gyro).
 * Retrieves all currently available motion sensor values.	 * Retrieves all currently available motion sensor values.
 * @param ax 16-bit signed integer container for acceleromete	 * @param ax 16-bit signed integer container for acceleromete
 * @param ay 16-bit signed integer container for acceleromete	 * @param ay 16-bit signed integer container for acceleromete
 * @param az 16-bit signed integer container for acceleromete	 * @param az 16-bit signed integer container for acceleromete
 * @param gx 16-bit signed integer container for gyroscope X-	 * @param gx 16-bit signed integer container for gyroscope X-
 * @param gy 16-bit signed integer container for gyroscope Y-	 * @param gy 16-bit signed integer container for gyroscope Y-
 * @param gz 16-bit signed integer container for gyroscope Z-	 * @param gz 16-bit signed integer container for gyroscope Z-
 * @see getAcceleration()					 * @see getAcceleration()
 * @see getRotation()						 * @see getRotation()
 * @see MPU6050_RA_ACCEL_XOUT_H					 * @see MPU6050_RA_ACCEL_XOUT_H
 */								 */
void MPU6050_getMotion6(int16_t *ax, int16_t *ay, int16_t *az |	void MPU6050_getMotion6(int16_t* ax, int16_t* ay, int16_t* az
                        int16_t *gy, int16_t *gz)	      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_XOUT_H
{							      |	    *ax = (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buffe
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_XO |	    *ay = (((int16_t)mpu6050.buffer[2]) << 8) | mpu6050.buffe
	*ax = (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.b |	    *az = (((int16_t)mpu6050.buffer[4]) << 8) | mpu6050.buffe
	*ay = (((int16_t)mpu6050.buffer[2]) << 8) | mpu6050.b |	    *gx = (((int16_t)mpu6050.buffer[8]) << 8) | mpu6050.buffe
	*az = (((int16_t)mpu6050.buffer[4]) << 8) | mpu6050.b |	    *gy = (((int16_t)mpu6050.buffer[10]) << 8) | mpu6050.buff
	*gx = (((int16_t)mpu6050.buffer[8]) << 8) | mpu6050.b |	    *gz = (((int16_t)mpu6050.buffer[12]) << 8) | mpu6050.buff
	*gy = (((int16_t)mpu6050.buffer[10]) << 8) | mpu6050. <
	*gz = (((int16_t)mpu6050.buffer[12]) << 8) | mpu6050. <
}								}
/** Get 3-axis accelerometer readings.				/** Get 3-axis accelerometer readings.
 * These registers store the most recent accelerometer measur	 * These registers store the most recent accelerometer measur
 * Accelerometer measurements are written to these registers 	 * Accelerometer measurements are written to these registers 
 * as defined in Register 25.					 * as defined in Register 25.
 *								 *
 * The accelerometer measurement registers, along with the te	 * The accelerometer measurement registers, along with the te
 * measurement registers, gyroscope measurement registers, an	 * measurement registers, gyroscope measurement registers, an
 * data registers, are composed of two sets of registers: an 	 * data registers, are composed of two sets of registers: an 
 * set and a user-facing read register set.			 * set and a user-facing read register set.
 *								 *
 * The data within the accelerometer sensors' internal regist	 * The data within the accelerometer sensors' internal regist
 * updated at the Sample Rate. Meanwhile, the user-facing rea	 * updated at the Sample Rate. Meanwhile, the user-facing rea
 * duplicates the internal register set's data values wheneve	 * duplicates the internal register set's data values wheneve
 * interface is idle. This guarantees that a burst read of se	 * interface is idle. This guarantees that a burst read of se
 * read measurements from the same sampling instant. Note tha	 * read measurements from the same sampling instant. Note tha
 * are not used, the user is responsible for ensuring a set o	 * are not used, the user is responsible for ensuring a set o
 * correspond to a single sampling instant by checking the Da	 * correspond to a single sampling instant by checking the Da
 *								 *
 * Each 16-bit accelerometer measurement has a full scale def	 * Each 16-bit accelerometer measurement has a full scale def
 * (Register 28). For each full scale setting, the accelerome	 * (Register 28). For each full scale setting, the accelerome
 * per LSB in ACCEL_xOUT is shown in the table below:		 * per LSB in ACCEL_xOUT is shown in the table below:
 *								 *
 * <pre>							 * <pre>
 * AFS_SEL | Full Scale Range | LSB Sensitivity			 * AFS_SEL | Full Scale Range | LSB Sensitivity
 * --------+------------------+----------------			 * --------+------------------+----------------
 * 0       | +/- 2g           | 8192 LSB/mg			 * 0       | +/- 2g           | 8192 LSB/mg
 * 1       | +/- 4g           | 4096 LSB/mg			 * 1       | +/- 4g           | 4096 LSB/mg
 * 2       | +/- 8g           | 2048 LSB/mg			 * 2       | +/- 8g           | 2048 LSB/mg
 * 3       | +/- 16g          | 1024 LSB/mg			 * 3       | +/- 16g          | 1024 LSB/mg
 * </pre>							 * </pre>
 *								 *
 * @param x 16-bit signed integer container for X-axis accele	 * @param x 16-bit signed integer container for X-axis accele
 * @param y 16-bit signed integer container for Y-axis accele	 * @param y 16-bit signed integer container for Y-axis accele
 * @param z 16-bit signed integer container for Z-axis accele	 * @param z 16-bit signed integer container for Z-axis accele
 * @see MPU6050_RA_GYRO_XOUT_H					 * @see MPU6050_RA_GYRO_XOUT_H
 */								 */
void MPU6050_getAcceleration(int16_t *x, int16_t *y, int16_t  |	void MPU6050_getAcceleration(int16_t* x, int16_t* y, int16_t*
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_XOUT_H
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_XO |	    *x = (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buffer
	*x = (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.bu |	    *y = (((int16_t)mpu6050.buffer[2]) << 8) | mpu6050.buffer
	*y = (((int16_t)mpu6050.buffer[2]) << 8) | mpu6050.bu |	    *z = (((int16_t)mpu6050.buffer[4]) << 8) | mpu6050.buffer
	*z = (((int16_t)mpu6050.buffer[4]) << 8) | mpu6050.bu <
}								}
/** Get X-axis accelerometer reading.				/** Get X-axis accelerometer reading.
 * @return X-axis acceleration measurement in 16-bit 2's comp	 * @return X-axis acceleration measurement in 16-bit 2's comp
 * @see getMotion6()						 * @see getMotion6()
 * @see MPU6050_RA_ACCEL_XOUT_H					 * @see MPU6050_RA_ACCEL_XOUT_H
 */								 */
int16_t MPU6050_getAccelerationX()			      |	int16_t MPU6050_getAccelerationX() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_XOUT_H
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_XO |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. <
}								}
/** Get Y-axis accelerometer reading.				/** Get Y-axis accelerometer reading.
 * @return Y-axis acceleration measurement in 16-bit 2's comp	 * @return Y-axis acceleration measurement in 16-bit 2's comp
 * @see getMotion6()						 * @see getMotion6()
 * @see MPU6050_RA_ACCEL_YOUT_H					 * @see MPU6050_RA_ACCEL_YOUT_H
 */								 */
int16_t MPU6050_getAccelerationY()			      |	int16_t MPU6050_getAccelerationY() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_YOUT_H
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_YO |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. <
}								}
/** Get Z-axis accelerometer reading.				/** Get Z-axis accelerometer reading.
 * @return Z-axis acceleration measurement in 16-bit 2's comp	 * @return Z-axis acceleration measurement in 16-bit 2's comp
 * @see getMotion6()						 * @see getMotion6()
 * @see MPU6050_RA_ACCEL_ZOUT_H					 * @see MPU6050_RA_ACCEL_ZOUT_H
 */								 */
int16_t MPU6050_getAccelerationZ()			      |	int16_t MPU6050_getAccelerationZ() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_ZOUT_H
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ACCEL_ZO |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. <
}								}

// TEMP_OUT_* registers						// TEMP_OUT_* registers

/** Get current internal temperature.				/** Get current internal temperature.
 * @return Temperature reading in 16-bit 2's complement forma	 * @return Temperature reading in 16-bit 2's complement forma
 * @see MPU6050_RA_TEMP_OUT_H					 * @see MPU6050_RA_TEMP_OUT_H
 */								 */
int16_t MPU6050_getTemperature()			      |	int16_t MPU6050_getTemperature() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_TEMP_OUT_H, 
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_TEMP_OUT |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. <
}								}

// GYRO_*OUT_* registers					// GYRO_*OUT_* registers

/** Get 3-axis gyroscope readings.				/** Get 3-axis gyroscope readings.
 * These gyroscope measurement registers, along with the acce	 * These gyroscope measurement registers, along with the acce
 * measurement registers, temperature measurement registers, 	 * measurement registers, temperature measurement registers, 
 * data registers, are composed of two sets of registers: an 	 * data registers, are composed of two sets of registers: an 
 * set and a user-facing read register set.			 * set and a user-facing read register set.
 * The data within the gyroscope sensors' internal register s	 * The data within the gyroscope sensors' internal register s
 * updated at the Sample Rate. Meanwhile, the user-facing rea	 * updated at the Sample Rate. Meanwhile, the user-facing rea
 * duplicates the internal register set's data values wheneve	 * duplicates the internal register set's data values wheneve
 * interface is idle. This guarantees that a burst read of se	 * interface is idle. This guarantees that a burst read of se
 * read measurements from the same sampling instant. Note tha	 * read measurements from the same sampling instant. Note tha
 * are not used, the user is responsible for ensuring a set o	 * are not used, the user is responsible for ensuring a set o
 * correspond to a single sampling instant by checking the Da	 * correspond to a single sampling instant by checking the Da
 *								 *
 * Each 16-bit gyroscope measurement has a full scale defined	 * Each 16-bit gyroscope measurement has a full scale defined
 * (Register 27). For each full scale setting, the gyroscopes	 * (Register 27). For each full scale setting, the gyroscopes
 * LSB in GYRO_xOUT is shown in the table below:		 * LSB in GYRO_xOUT is shown in the table below:
 *								 *
 * <pre>							 * <pre>
 * FS_SEL | Full Scale Range   | LSB Sensitivity		 * FS_SEL | Full Scale Range   | LSB Sensitivity
 * -------+--------------------+----------------		 * -------+--------------------+----------------
 * 0      | +/- 250 degrees/s  | 131 LSB/deg/s			 * 0      | +/- 250 degrees/s  | 131 LSB/deg/s
 * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s			 * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s
 * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s			 * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s
 * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s			 * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s
 * </pre>							 * </pre>
 *								 *
 * @param x 16-bit signed integer container for X-axis rotati	 * @param x 16-bit signed integer container for X-axis rotati
 * @param y 16-bit signed integer container for Y-axis rotati	 * @param y 16-bit signed integer container for Y-axis rotati
 * @param z 16-bit signed integer container for Z-axis rotati	 * @param z 16-bit signed integer container for Z-axis rotati
 * @see getMotion6()						 * @see getMotion6()
 * @see MPU6050_RA_GYRO_XOUT_H					 * @see MPU6050_RA_GYRO_XOUT_H
 */								 */
void MPU6050_getRotation(int16_t *x, int16_t *y, int16_t *z)  |	void MPU6050_getRotation(int16_t* x, int16_t* y, int16_t* z) 
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_XOUT_H,
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_XOU |	    *x = (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buffer
	*x = (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.bu |	    *y = (((int16_t)mpu6050.buffer[2]) << 8) | mpu6050.buffer
	*y = (((int16_t)mpu6050.buffer[2]) << 8) | mpu6050.bu |	    *z = (((int16_t)mpu6050.buffer[4]) << 8) | mpu6050.buffer
	*z = (((int16_t)mpu6050.buffer[4]) << 8) | mpu6050.bu <
}								}
/** Get X-axis gyroscope reading.				/** Get X-axis gyroscope reading.
 * @return X-axis rotation measurement in 16-bit 2's compleme	 * @return X-axis rotation measurement in 16-bit 2's compleme
 * @see getMotion6()						 * @see getMotion6()
 * @see MPU6050_RA_GYRO_XOUT_H					 * @see MPU6050_RA_GYRO_XOUT_H
 */								 */
int16_t MPU6050_getRotationX()				      |	int16_t MPU6050_getRotationX() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_XOUT_H,
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_XOU |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. <
}								}
/** Get Y-axis gyroscope reading.				/** Get Y-axis gyroscope reading.
 * @return Y-axis rotation measurement in 16-bit 2's compleme	 * @return Y-axis rotation measurement in 16-bit 2's compleme
 * @see getMotion6()						 * @see getMotion6()
 * @see MPU6050_RA_GYRO_YOUT_H					 * @see MPU6050_RA_GYRO_YOUT_H
 */								 */
int16_t MPU6050_getRotationY()				      |	int16_t MPU6050_getRotationY() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_YOUT_H,
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_YOU |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. <
}								}
/** Get Z-axis gyroscope reading.				/** Get Z-axis gyroscope reading.
 * @return Z-axis rotation measurement in 16-bit 2's compleme	 * @return Z-axis rotation measurement in 16-bit 2's compleme
 * @see getMotion6()						 * @see getMotion6()
 * @see MPU6050_RA_GYRO_ZOUT_H					 * @see MPU6050_RA_GYRO_ZOUT_H
 */								 */
int16_t MPU6050_getRotationZ()				      |	int16_t MPU6050_getRotationZ() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_ZOUT_H,
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_GYRO_ZOU |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. <
}								}

// EXT_SENS_DATA_* registers					// EXT_SENS_DATA_* registers

/** Read single byte from external sensor data register.	/** Read single byte from external sensor data register.
 * These registers store data read from external sensors by t	 * These registers store data read from external sensors by t
 * and 3 on the auxiliary I2C interface. Data read by Slave 4	 * and 3 on the auxiliary I2C interface. Data read by Slave 4
 * I2C_SLV4_DI (Register 53).					 * I2C_SLV4_DI (Register 53).
 *								 *
 * External sensor data is written to these registers at the 	 * External sensor data is written to these registers at the 
 * defined in Register 25. This access rate can be reduced by	 * defined in Register 25. This access rate can be reduced by
 * Delay Enable registers (Register 103).			 * Delay Enable registers (Register 103).
 *								 *
 * External sensor data registers, along with the gyroscope m	 * External sensor data registers, along with the gyroscope m
 * registers, accelerometer measurement registers, and temper	 * registers, accelerometer measurement registers, and temper
 * registers, are composed of two sets of registers: an inter	 * registers, are composed of two sets of registers: an inter
 * and a user-facing read register set.				 * and a user-facing read register set.
 *								 *
 * The data within the external sensors' internal register se	 * The data within the external sensors' internal register se
 * at the Sample Rate (or the reduced access rate) whenever t	 * at the Sample Rate (or the reduced access rate) whenever t
 * is idle. This guarantees that a burst read of sensor regis	 * is idle. This guarantees that a burst read of sensor regis
 * measurements from the same sampling instant. Note that if 	 * measurements from the same sampling instant. Note that if 
 * used, the user is responsible for ensuring a set of single	 * used, the user is responsible for ensuring a set of single
 * correspond to a single sampling instant by checking the Da	 * correspond to a single sampling instant by checking the Da
 *								 *
 * Data is placed in these external sensor data registers acc	 * Data is placed in these external sensor data registers acc
 * I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_	 * I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_
 * 42, 45, and 48). When more than zero bytes are read (I2C_S	 * 42, 45, and 48). When more than zero bytes are read (I2C_S
 * an enabled slave (I2C_SLVx_EN = 1), the slave is read at t	 * an enabled slave (I2C_SLVx_EN = 1), the slave is read at t
 * defined in Register 25) or delayed rate (if specified in R	 * defined in Register 25) or delayed rate (if specified in R
 * 103). During each Sample cycle, slave reads are performed 	 * 103). During each Sample cycle, slave reads are performed 
 * number. If all slaves are enabled with more than zero byte	 * number. If all slaves are enabled with more than zero byte
 * order will be Slave 0, followed by Slave 1, Slave 2, and S	 * order will be Slave 0, followed by Slave 1, Slave 2, and S
 *								 *
 * Each enabled slave will have EXT_SENS_DATA registers assoc	 * Each enabled slave will have EXT_SENS_DATA registers assoc
 * number of bytes read (I2C_SLVx_LEN) in order of slave numb	 * number of bytes read (I2C_SLVx_LEN) in order of slave numb
 * EXT_SENS_DATA_00. Note that this means enabling or disabli	 * EXT_SENS_DATA_00. Note that this means enabling or disabli
 * change the higher numbered slaves' associated registers. F	 * change the higher numbered slaves' associated registers. F
 * fewer total bytes are being read from the external sensors	 * fewer total bytes are being read from the external sensors
 * such a change, then the data remaining in the registers wh	 * such a change, then the data remaining in the registers wh
 * an associated slave device (i.e. high numbered registers) 	 * an associated slave device (i.e. high numbered registers) 
 * these previously allocated registers unless reset.		 * these previously allocated registers unless reset.
 *								 *
 * If the sum of the read lengths of all SLVx transactions ex	 * If the sum of the read lengths of all SLVx transactions ex
 * available EXT_SENS_DATA registers, the excess bytes will b	 * available EXT_SENS_DATA registers, the excess bytes will b
 * are 24 EXT_SENS_DATA registers and hence the total read le	 * are 24 EXT_SENS_DATA registers and hence the total read le
 * the slaves cannot be greater than 24 or some bytes will be	 * the slaves cannot be greater than 24 or some bytes will be
 *								 *
 * Note: Slave 4's behavior is distinct from that of Slaves 0	 * Note: Slave 4's behavior is distinct from that of Slaves 0
 * information regarding the characteristics of Slave 4, plea	 * information regarding the characteristics of Slave 4, plea
 * Registers 49 to 53.						 * Registers 49 to 53.
 *								 *
 * EXAMPLE:							 * EXAMPLE:
 * Suppose that Slave 0 is enabled with 4 bytes to be read (I	 * Suppose that Slave 0 is enabled with 4 bytes to be read (I
 * I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to	 * I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to
 * I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation,	 * I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation,
 * through _03 will be associated with Slave 0, while EXT_SEN	 * through _03 will be associated with Slave 0, while EXT_SEN
 * will be associated with Slave 1. If Slave 2 is enabled as 	 * will be associated with Slave 1. If Slave 2 is enabled as 
 * starting from EXT_SENS_DATA_06 will be allocated to Slave 	 * starting from EXT_SENS_DATA_06 will be allocated to Slave 
 *								 *
 * If Slave 2 is disabled while Slave 3 is enabled in this sa	 * If Slave 2 is disabled while Slave 3 is enabled in this sa
 * registers starting from EXT_SENS_DATA_06 will be allocated	 * registers starting from EXT_SENS_DATA_06 will be allocated
 * instead.							 * instead.
 *								 *
 * REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE	 * REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE
 * If a slave is disabled at any time, the space initially al	 * If a slave is disabled at any time, the space initially al
 * slave in the EXT_SENS_DATA register, will remain associate	 * slave in the EXT_SENS_DATA register, will remain associate
 * This is to avoid dynamic adjustment of the register alloca	 * This is to avoid dynamic adjustment of the register alloca
 *								 *
 * The allocation of the EXT_SENS_DATA registers is recompute	 * The allocation of the EXT_SENS_DATA registers is recompute
 * slaves are disabled, or (2) the I2C_MST_RST bit is set (Re	 * slaves are disabled, or (2) the I2C_MST_RST bit is set (Re
 *								 *
 * This above is also true if one of the slaves gets NACKed a	 * This above is also true if one of the slaves gets NACKed a
 * functioning.							 * functioning.
 *								 *
 * @param position Starting position (0-23)			 * @param position Starting position (0-23)
 * @return Byte read from register				 * @return Byte read from register
 */								 */
uint8_t MPU6050_getExternalSensorByte(int position)	      |	uint8_t MPU6050_getExternalSensorByte(int position) {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_EXT_SENS_DATA
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_EXT_SENS_ |	    return mpu6050.buffer[0];
	                mpu6050.buffer);		      <
	return mpu6050.buffer[0];			      <
}								}
/** Read word (2 bytes) from external sensor data registers.	/** Read word (2 bytes) from external sensor data registers.
 * @param position Starting position (0-21)			 * @param position Starting position (0-21)
 * @return Word read from register				 * @return Word read from register
 * @see getExternalSensorByte()					 * @see getExternalSensorByte()
 */								 */
uint16_t MPU6050_getExternalSensorWord(int position)	      |	uint16_t MPU6050_getExternalSensorWord(int position) {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_EXT_SENS_DAT
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_EXT_SENS |	    return (((uint16_t)mpu6050.buffer[0]) << 8) | mpu6050.buf
	                 mpu6050.buffer);		      <
	return (((uint16_t)mpu6050.buffer[0]) << 8) | mpu6050 <
}								}
/** Read double word (4 bytes) from external sensor data regi	/** Read double word (4 bytes) from external sensor data regi
 * @param position Starting position (0-20)			 * @param position Starting position (0-20)
 * @return Double word read from registers			 * @return Double word read from registers
 * @see getExternalSensorByte()					 * @see getExternalSensorByte()
 */								 */
uint32_t MPU6050_getExternalSensorDWord(int position)	      |	uint32_t MPU6050_getExternalSensorDWord(int position) {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_EXT_SENS_DAT
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_EXT_SENS |	    return (((uint32_t)mpu6050.buffer[0]) << 24) | (((uint32_
	                 mpu6050.buffer);		      <
	return (((uint32_t)mpu6050.buffer[0]) << 24) | (((uin <
	        16) | (((uint16_t)mpu6050.buffer[2]) << 8) |  <
}								}

// MOT_DETECT_STATUS register					// MOT_DETECT_STATUS register

/** Get X-axis negative motion detection interrupt status.	/** Get X-axis negative motion detection interrupt status.
 * @return Motion detection status				 * @return Motion detection status
 * @see MPU6050_RA_MOT_DETECT_STATUS				 * @see MPU6050_RA_MOT_DETECT_STATUS
 * @see MPU6050_MOTION_MOT_XNEG_BIT				 * @see MPU6050_MOTION_MOT_XNEG_BIT
 */								 */
bool MPU6050_getXNegMotionDetected()			      |	bool MPU6050_getXNegMotionDetected() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_STA
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT |	    return mpu6050.buffer[0];
	               MPU6050_MOTION_MOT_XNEG_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Get X-axis positive motion detection interrupt status.	/** Get X-axis positive motion detection interrupt status.
 * @return Motion detection status				 * @return Motion detection status
 * @see MPU6050_RA_MOT_DETECT_STATUS				 * @see MPU6050_RA_MOT_DETECT_STATUS
 * @see MPU6050_MOTION_MOT_XPOS_BIT				 * @see MPU6050_MOTION_MOT_XPOS_BIT
 */								 */
bool MPU6050_getXPosMotionDetected()			      |	bool MPU6050_getXPosMotionDetected() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_STA
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT |	    return mpu6050.buffer[0];
	               MPU6050_MOTION_MOT_XPOS_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Get Y-axis negative motion detection interrupt status.	/** Get Y-axis negative motion detection interrupt status.
 * @return Motion detection status				 * @return Motion detection status
 * @see MPU6050_RA_MOT_DETECT_STATUS				 * @see MPU6050_RA_MOT_DETECT_STATUS
 * @see MPU6050_MOTION_MOT_YNEG_BIT				 * @see MPU6050_MOTION_MOT_YNEG_BIT
 */								 */
bool MPU6050_getYNegMotionDetected()			      |	bool MPU6050_getYNegMotionDetected() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_STA
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT |	    return mpu6050.buffer[0];
	               MPU6050_MOTION_MOT_YNEG_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Get Y-axis positive motion detection interrupt status.	/** Get Y-axis positive motion detection interrupt status.
 * @return Motion detection status				 * @return Motion detection status
 * @see MPU6050_RA_MOT_DETECT_STATUS				 * @see MPU6050_RA_MOT_DETECT_STATUS
 * @see MPU6050_MOTION_MOT_YPOS_BIT				 * @see MPU6050_MOTION_MOT_YPOS_BIT
 */								 */
bool MPU6050_getYPosMotionDetected()			      |	bool MPU6050_getYPosMotionDetected() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_STA
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT |	    return mpu6050.buffer[0];
	               MPU6050_MOTION_MOT_YPOS_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Get Z-axis negative motion detection interrupt status.	/** Get Z-axis negative motion detection interrupt status.
 * @return Motion detection status				 * @return Motion detection status
 * @see MPU6050_RA_MOT_DETECT_STATUS				 * @see MPU6050_RA_MOT_DETECT_STATUS
 * @see MPU6050_MOTION_MOT_ZNEG_BIT				 * @see MPU6050_MOTION_MOT_ZNEG_BIT
 */								 */
bool MPU6050_getZNegMotionDetected()			      |	bool MPU6050_getZNegMotionDetected() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_STA
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT |	    return mpu6050.buffer[0];
	               MPU6050_MOTION_MOT_ZNEG_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Get Z-axis positive motion detection interrupt status.	/** Get Z-axis positive motion detection interrupt status.
 * @return Motion detection status				 * @return Motion detection status
 * @see MPU6050_RA_MOT_DETECT_STATUS				 * @see MPU6050_RA_MOT_DETECT_STATUS
 * @see MPU6050_MOTION_MOT_ZPOS_BIT				 * @see MPU6050_MOTION_MOT_ZPOS_BIT
 */								 */
bool MPU6050_getZPosMotionDetected()			      |	bool MPU6050_getZPosMotionDetected() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_STA
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT |	    return mpu6050.buffer[0];
	               MPU6050_MOTION_MOT_ZPOS_BIT, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Get zero motion detection interrupt status.			/** Get zero motion detection interrupt status.
 * @return Motion detection status				 * @return Motion detection status
 * @see MPU6050_RA_MOT_DETECT_STATUS				 * @see MPU6050_RA_MOT_DETECT_STATUS
 * @see MPU6050_MOTION_MOT_ZRMOT_BIT				 * @see MPU6050_MOTION_MOT_ZRMOT_BIT
 */								 */
bool MPU6050_getZeroMotionDetected()			      |	bool MPU6050_getZeroMotionDetected() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_STA
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_MOT_DETECT |	    return mpu6050.buffer[0];
	               MPU6050_MOTION_MOT_ZRMOT_BIT, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}

// I2C_SLV*_DO register						// I2C_SLV*_DO register

/** Write byte to Data Output container for specified slave.	/** Write byte to Data Output container for specified slave.
 * This register holds the output data written into Slave whe	 * This register holds the output data written into Slave whe
 * write mode. For further information regarding Slave contro	 * write mode. For further information regarding Slave contro
 * refer to Registers 37 to 39 and immediately following.	 * refer to Registers 37 to 39 and immediately following.
 * @param num Slave number (0-3)				 * @param num Slave number (0-3)
 * @param data Byte to write					 * @param data Byte to write
 * @see MPU6050_RA_I2C_SLV0_DO					 * @see MPU6050_RA_I2C_SLV0_DO
 */								 */
void MPU6050_setSlaveOutputByte(uint8_t num, uint8_t data)    |	void MPU6050_setSlaveOutputByte(uint8_t num, uint8_t data) {
{							      |	    if (num > 3) return;
	if (num > 3) return;				      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0_DO 
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_I2C_SLV0 <
}								}

// I2C_MST_DELAY_CTRL register					// I2C_MST_DELAY_CTRL register

/** Get external data shadow delay enabled status.		/** Get external data shadow delay enabled status.
 * This register is used to specify the timing of external se	 * This register is used to specify the timing of external se
 * shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of 	 * shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of 
 * sensor data is delayed until all data has been received.	 * sensor data is delayed until all data has been received.
 * @return Current external data shadow delay enabled status.	 * @return Current external data shadow delay enabled status.
 * @see MPU6050_RA_I2C_MST_DELAY_CTRL				 * @see MPU6050_RA_I2C_MST_DELAY_CTRL
 * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT			 * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT
 */								 */
bool MPU6050_getExternalShadowDelayEnabled()		      |	bool MPU6050_getExternalShadowDelayEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_DELAY_
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_DE |	    return mpu6050.buffer[0];
	               MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT, <
	return mpu6050.buffer[0];			      <
}								}
/** Set external data shadow delay enabled status.		/** Set external data shadow delay enabled status.
 * @param enabled New external data shadow delay enabled stat	 * @param enabled New external data shadow delay enabled stat
 * @see getExternalShadowDelayEnabled()				 * @see getExternalShadowDelayEnabled()
 * @see MPU6050_RA_I2C_MST_DELAY_CTRL				 * @see MPU6050_RA_I2C_MST_DELAY_CTRL
 * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT			 * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT
 */								 */
void MPU6050_setExternalShadowDelayEnabled(bool enabled)      |	void MPU6050_setExternalShadowDelayEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_DELAY
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_D <
	                MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT <
}								}
/** Get slave delay enabled status.				/** Get slave delay enabled status.
 * When a particular slave delay is enabled, the rate of acce	 * When a particular slave delay is enabled, the rate of acce
 * slave device is reduced. When a slave's access rate is dec	 * slave device is reduced. When a slave's access rate is dec
 * the Sample Rate, the slave is accessed every:		 * the Sample Rate, the slave is accessed every:
 *								 *
 *     1 / (1 + I2C_MST_DLY) Samples				 *     1 / (1 + I2C_MST_DLY) Samples
 *								 *
 * This base Sample Rate in turn is determined by SMPLRT_DIV 	 * This base Sample Rate in turn is determined by SMPLRT_DIV 
 * and DLPF_CFG (register 26).					 * and DLPF_CFG (register 26).
 *								 *
 * For further information regarding I2C_MST_DLY, please refe	 * For further information regarding I2C_MST_DLY, please refe
 * For further information regarding the Sample Rate, please 	 * For further information regarding the Sample Rate, please 
 *								 *
 * @param num Slave number (0-4)				 * @param num Slave number (0-4)
 * @return Current slave delay enabled status.			 * @return Current slave delay enabled status.
 * @see MPU6050_RA_I2C_MST_DELAY_CTRL				 * @see MPU6050_RA_I2C_MST_DELAY_CTRL
 * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT			 * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT
 */								 */
bool MPU6050_getSlaveDelayEnabled(uint8_t num)		      |	bool MPU6050_getSlaveDelayEnabled(uint8_t num) {
{							      |	    // MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 is 3,
	// MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 i |	    if (num > 4) return 0;
	if (num > 4) return 0;				      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_DELAY_
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_DE |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set slave delay enabled status.				/** Set slave delay enabled status.
 * @param num Slave number (0-4)				 * @param num Slave number (0-4)
 * @param enabled New slave delay enabled status.		 * @param enabled New slave delay enabled status.
 * @see MPU6050_RA_I2C_MST_DELAY_CTRL				 * @see MPU6050_RA_I2C_MST_DELAY_CTRL
 * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT			 * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT
 */								 */
void MPU6050_setSlaveDelayEnabled(uint8_t num, bool enabled)  |	void MPU6050_setSlaveDelayEnabled(uint8_t num, bool enabled) 
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_DELAY
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_I2C_MST_D <
}								}

// SIGNAL_PATH_RESET register					// SIGNAL_PATH_RESET register

/** Reset gyroscope signal path.				/** Reset gyroscope signal path.
 * The reset will revert the signal path analog to digital co	 * The reset will revert the signal path analog to digital co
 * filters to their power up configurations.			 * filters to their power up configurations.
 * @see MPU6050_RA_SIGNAL_PATH_RESET				 * @see MPU6050_RA_SIGNAL_PATH_RESET
 * @see MPU6050_PATHRESET_GYRO_RESET_BIT			 * @see MPU6050_PATHRESET_GYRO_RESET_BIT
 */								 */
void MPU6050_resetGyroscopePath()			      |	void MPU6050_resetGyroscopePath() {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_SIGNAL_PATH_R
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_SIGNAL_PA <
	                MPU6050_PATHRESET_GYRO_RESET_BIT, tru <
}								}
/** Reset accelerometer signal path.				/** Reset accelerometer signal path.
 * The reset will revert the signal path analog to digital co	 * The reset will revert the signal path analog to digital co
 * filters to their power up configurations.			 * filters to their power up configurations.
 * @see MPU6050_RA_SIGNAL_PATH_RESET				 * @see MPU6050_RA_SIGNAL_PATH_RESET
 * @see MPU6050_PATHRESET_ACCEL_RESET_BIT			 * @see MPU6050_PATHRESET_ACCEL_RESET_BIT
 */								 */
void MPU6050_resetAccelerometerPath()			      |	void MPU6050_resetAccelerometerPath() {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_SIGNAL_PATH_R
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_SIGNAL_PA <
	                MPU6050_PATHRESET_ACCEL_RESET_BIT, tr <
}								}
/** Reset temperature sensor signal path.			/** Reset temperature sensor signal path.
 * The reset will revert the signal path analog to digital co	 * The reset will revert the signal path analog to digital co
 * filters to their power up configurations.			 * filters to their power up configurations.
 * @see MPU6050_RA_SIGNAL_PATH_RESET				 * @see MPU6050_RA_SIGNAL_PATH_RESET
 * @see MPU6050_PATHRESET_TEMP_RESET_BIT			 * @see MPU6050_PATHRESET_TEMP_RESET_BIT
 */								 */
void MPU6050_resetTemperaturePath()			      |	void MPU6050_resetTemperaturePath() {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_SIGNAL_PATH_R
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_SIGNAL_PA <
	                MPU6050_PATHRESET_TEMP_RESET_BIT, tru <
}								}

// MOT_DETECT_CTRL register					// MOT_DETECT_CTRL register

/** Get accelerometer power-on delay.				/** Get accelerometer power-on delay.
 * The accelerometer data path provides samples to the sensor	 * The accelerometer data path provides samples to the sensor
 * detection, Zero Motion detection, and Free Fall detection 	 * detection, Zero Motion detection, and Free Fall detection 
 * signal path contains filters which must be flushed on wake	 * signal path contains filters which must be flushed on wake
 * samples before the detection modules begin operations. The	 * samples before the detection modules begin operations. The
 * delay, of 4ms can be lengthened by up to 3ms. This additio	 * delay, of 4ms can be lengthened by up to 3ms. This additio
 * specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The 	 * specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The 
 * any value above zero unless instructed otherwise by InvenS	 * any value above zero unless instructed otherwise by InvenS
 * to Section 8 of the MPU-6000/MPU-6050 Product Specificatio	 * to Section 8 of the MPU-6000/MPU-6050 Product Specificatio
 * further information regarding the detection modules.		 * further information regarding the detection modules.
 * @return Current accelerometer power-on delay			 * @return Current accelerometer power-on delay
 * @see MPU6050_RA_MOT_DETECT_CTRL				 * @see MPU6050_RA_MOT_DETECT_CTRL
 * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT			 * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT
 */								 */
uint8_t MPU6050_getAccelerometerPowerOnDelay()		      |	uint8_t MPU6050_getAccelerometerPowerOnDelay() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_CT
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_MOT_DETEC |	    return mpu6050.buffer[0];
	                MPU6050_DETECT_ACCEL_ON_DELAY_BIT, MP <
	                mpu6050.buffer);		      <
	return mpu6050.buffer[0];			      <
}								}
/** Set accelerometer power-on delay.				/** Set accelerometer power-on delay.
 * @param delay New accelerometer power-on delay (0-3)		 * @param delay New accelerometer power-on delay (0-3)
 * @see getAccelerometerPowerOnDelay()				 * @see getAccelerometerPowerOnDelay()
 * @see MPU6050_RA_MOT_DETECT_CTRL				 * @see MPU6050_RA_MOT_DETECT_CTRL
 * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT			 * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT
 */								 */
void MPU6050_setAccelerometerPowerOnDelay(uint8_t delay)      |	void MPU6050_setAccelerometerPowerOnDelay(uint8_t delay) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_C
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_MOT_DETE <
	                 MPU6050_DETECT_ACCEL_ON_DELAY_BIT, M <
}								}
/** Get Free Fall detection counter decrement configuration.	/** Get Free Fall detection counter decrement configuration.
 * Detection is registered by the Free Fall detection module 	 * Detection is registered by the Free Fall detection module 
 * measurements meet their respective threshold conditions ov	 * measurements meet their respective threshold conditions ov
 * number of samples. When the threshold conditions are met, 	 * number of samples. When the threshold conditions are met, 
 * detection counter increments by 1. The user may control th	 * detection counter increments by 1. The user may control th
 * detection counter decrements when the threshold condition 	 * detection counter decrements when the threshold condition 
 * configuring FF_COUNT. The decrement rate can be set accord	 * configuring FF_COUNT. The decrement rate can be set accord
 * following table:						 * following table:
 *								 *
 * <pre>							 * <pre>
 * FF_COUNT | Counter Decrement					 * FF_COUNT | Counter Decrement
 * ---------+------------------					 * ---------+------------------
 * 0        | Reset						 * 0        | Reset
 * 1        | 1							 * 1        | 1
 * 2        | 2							 * 2        | 2
 * 3        | 4							 * 3        | 4
 * </pre>							 * </pre>
 *								 *
 * When FF_COUNT is configured to 0 (reset), any non-qualifyi	 * When FF_COUNT is configured to 0 (reset), any non-qualifyi
 * reset the counter to 0. For further information on Free Fa	 * reset the counter to 0. For further information on Free Fa
 * please refer to Registers 29 to 32.				 * please refer to Registers 29 to 32.
 *								 *
 * @return Current decrement configuration			 * @return Current decrement configuration
 * @see MPU6050_RA_MOT_DETECT_CTRL				 * @see MPU6050_RA_MOT_DETECT_CTRL
 * @see MPU6050_DETECT_FF_COUNT_BIT				 * @see MPU6050_DETECT_FF_COUNT_BIT
 */								 */
uint8_t MPU6050_getFreefallDetectionCounterDecrement()	      |	uint8_t MPU6050_getFreefallDetectionCounterDecrement() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_CT
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_MOT_DETEC |	    return mpu6050.buffer[0];
	                MPU6050_DETECT_FF_COUNT_BIT, MPU6050_ <
	return mpu6050.buffer[0];			      <
}								}
/** Set Free Fall detection counter decrement configuration.	/** Set Free Fall detection counter decrement configuration.
 * @param decrement New decrement configuration value		 * @param decrement New decrement configuration value
 * @see getFreefallDetectionCounterDecrement()			 * @see getFreefallDetectionCounterDecrement()
 * @see MPU6050_RA_MOT_DETECT_CTRL				 * @see MPU6050_RA_MOT_DETECT_CTRL
 * @see MPU6050_DETECT_FF_COUNT_BIT				 * @see MPU6050_DETECT_FF_COUNT_BIT
 */								 */
void MPU6050_setFreefallDetectionCounterDecrement(uint8_t dec |	void MPU6050_setFreefallDetectionCounterDecrement(uint8_t dec
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_C
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_MOT_DETE <
	                 MPU6050_DETECT_FF_COUNT_BIT, MPU6050 <
}								}
/** Get Motion detection counter decrement configuration.	/** Get Motion detection counter decrement configuration.
 * Detection is registered by the Motion detection module aft	 * Detection is registered by the Motion detection module aft
 * measurements meet their respective threshold conditions ov	 * measurements meet their respective threshold conditions ov
 * number of samples. When the threshold conditions are met, 	 * number of samples. When the threshold conditions are met, 
 * detection counter increments by 1. The user may control th	 * detection counter increments by 1. The user may control th
 * detection counter decrements when the threshold condition 	 * detection counter decrements when the threshold condition 
 * configuring MOT_COUNT. The decrement rate can be set accor	 * configuring MOT_COUNT. The decrement rate can be set accor
 * following table:						 * following table:
 *								 *
 * <pre>							 * <pre>
 * MOT_COUNT | Counter Decrement				 * MOT_COUNT | Counter Decrement
 * ----------+------------------				 * ----------+------------------
 * 0         | Reset						 * 0         | Reset
 * 1         | 1						 * 1         | 1
 * 2         | 2						 * 2         | 2
 * 3         | 4						 * 3         | 4
 * </pre>							 * </pre>
 *								 *
 * When MOT_COUNT is configured to 0 (reset), any non-qualify	 * When MOT_COUNT is configured to 0 (reset), any non-qualify
 * reset the counter to 0. For further information on Motion 	 * reset the counter to 0. For further information on Motion 
 * please refer to Registers 29 to 32.				 * please refer to Registers 29 to 32.
 *								 *
 */								 */
uint8_t MPU6050_getMotionDetectionCounterDecrement()	      |	uint8_t MPU6050_getMotionDetectionCounterDecrement() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_CT
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_MOT_DETEC |	    return mpu6050.buffer[0];
	                MPU6050_DETECT_MOT_COUNT_BIT, MPU6050 <
	return mpu6050.buffer[0];			      <
}								}
/** Set Motion detection counter decrement configuration.	/** Set Motion detection counter decrement configuration.
 * @param decrement New decrement configuration value		 * @param decrement New decrement configuration value
 * @see getMotionDetectionCounterDecrement()			 * @see getMotionDetectionCounterDecrement()
 * @see MPU6050_RA_MOT_DETECT_CTRL				 * @see MPU6050_RA_MOT_DETECT_CTRL
 * @see MPU6050_DETECT_MOT_COUNT_BIT				 * @see MPU6050_DETECT_MOT_COUNT_BIT
 */								 */
void MPU6050_setMotionDetectionCounterDecrement(uint8_t decre |	void MPU6050_setMotionDetectionCounterDecrement(uint8_t decre
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_MOT_DETECT_C
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_MOT_DETE <
	                 MPU6050_DETECT_MOT_COUNT_BIT, MPU605 <
}								}

// USER_CTRL register						// USER_CTRL register

/** Get FIFO enabled status.					/** Get FIFO enabled status.
 * When this bit is set to 0, the FIFO mpu6050.buffer is disa	 * When this bit is set to 0, the FIFO mpu6050.buffer is disa
 * cannot be written to or read from while disabled. The FIFO	 * cannot be written to or read from while disabled. The FIFO
 * does not change unless the MPU-60X0 is power cycled.		 * does not change unless the MPU-60X0 is power cycled.
 * @return Current FIFO enabled status				 * @return Current FIFO enabled status
 * @see MPU6050_RA_USER_CTRL					 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_FIFO_EN_BIT				 * @see MPU6050_USERCTRL_FIFO_EN_BIT
 */								 */
bool MPU6050_getFIFOEnabled()				      |	bool MPU6050_getFIFOEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MPU
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, |	    return mpu6050.buffer[0];
	               MPU6050_USERCTRL_FIFO_EN_BIT, mpu6050. <
	return mpu6050.buffer[0];			      <
}								}
/** Set FIFO enabled status.					/** Set FIFO enabled status.
 * @param enabled New FIFO enabled status			 * @param enabled New FIFO enabled status
 * @see getFIFOEnabled()					 * @see getFIFOEnabled()
 * @see MPU6050_RA_USER_CTRL					 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_FIFO_EN_BIT				 * @see MPU6050_USERCTRL_FIFO_EN_BIT
 */								 */
void MPU6050_setFIFOEnabled(bool enabled)		      |	void MPU6050_setFIFOEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL <
	                MPU6050_USERCTRL_FIFO_EN_BIT, enabled <
}								}
/** Get I2C Master Mode enabled status.				/** Get I2C Master Mode enabled status.
 * When this mode is enabled, the MPU-60X0 acts as the I2C Ma	 * When this mode is enabled, the MPU-60X0 acts as the I2C Ma
 * external sensor slave devices on the auxiliary I2C bus. Wh	 * external sensor slave devices on the auxiliary I2C bus. Wh
 * cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_	 * cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_
 * driven by the primary I2C bus (SDA and SCL). This is a pre	 * driven by the primary I2C bus (SDA and SCL). This is a pre
 * enabling Bypass Mode. For further information regarding By	 * enabling Bypass Mode. For further information regarding By
 * refer to Register 55.					 * refer to Register 55.
 * @return Current I2C Master Mode enabled status		 * @return Current I2C Master Mode enabled status
 * @see MPU6050_RA_USER_CTRL					 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_I2C_MST_EN_BIT				 * @see MPU6050_USERCTRL_I2C_MST_EN_BIT
 */								 */
bool MPU6050_getI2CMasterModeEnabled()			      |	bool MPU6050_getI2CMasterModeEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MPU
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, |	    return mpu6050.buffer[0];
	               MPU6050_USERCTRL_I2C_MST_EN_BIT, mpu60 <
	return mpu6050.buffer[0];			      <
}								}
/** Set I2C Master Mode enabled status.				/** Set I2C Master Mode enabled status.
 * @param enabled New I2C Master Mode enabled status		 * @param enabled New I2C Master Mode enabled status
 * @see getI2CMasterModeEnabled()				 * @see getI2CMasterModeEnabled()
 * @see MPU6050_RA_USER_CTRL					 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_I2C_MST_EN_BIT				 * @see MPU6050_USERCTRL_I2C_MST_EN_BIT
 */								 */
void MPU6050_setI2CMasterModeEnabled(bool enabled)	      |	void MPU6050_setI2CMasterModeEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL <
	                MPU6050_USERCTRL_I2C_MST_EN_BIT, enab <
}								}
/** Switch from I2C to SPI mode (MPU-6000 only)			/** Switch from I2C to SPI mode (MPU-6000 only)
 * If this is set, the primary SPI interface will be enabled 	 * If this is set, the primary SPI interface will be enabled 
 * disabled primary I2C interface.				 * disabled primary I2C interface.
 */								 */
void MPU6050_switchSPIEnabled(bool enabled)		      |	void MPU6050_switchSPIEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL <
	                MPU6050_USERCTRL_I2C_IF_DIS_BIT, enab <
}								}
/** Reset the FIFO.						/** Reset the FIFO.
 * This bit resets the FIFO mpu6050.buffer when set to 1 whil	 * This bit resets the FIFO mpu6050.buffer when set to 1 whil
 * bit automatically clears to 0 after the reset has been tri	 * bit automatically clears to 0 after the reset has been tri
 * @see MPU6050_RA_USER_CTRL					 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_FIFO_RESET_BIT				 * @see MPU6050_USERCTRL_FIFO_RESET_BIT
 */								 */
void MPU6050_resetFIFO()				      |	void MPU6050_resetFIFO() {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL <
	                MPU6050_USERCTRL_FIFO_RESET_BIT, true <
}								}
/** Reset the I2C Master.					/** Reset the I2C Master.
 * This bit resets the I2C Master when set to 1 while I2C_MST	 * This bit resets the I2C Master when set to 1 while I2C_MST
 * This bit automatically clears to 0 after the reset has bee	 * This bit automatically clears to 0 after the reset has bee
 * @see MPU6050_RA_USER_CTRL					 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_I2C_MST_RESET_BIT			 * @see MPU6050_USERCTRL_I2C_MST_RESET_BIT
 */								 */
void MPU6050_resetI2CMaster()				      |	void MPU6050_resetI2CMaster() {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL <
	                MPU6050_USERCTRL_I2C_MST_RESET_BIT, t <
}								}
/** Reset all sensor registers and signal paths.		/** Reset all sensor registers and signal paths.
 * When set to 1, this bit resets the signal paths for all se	 * When set to 1, this bit resets the signal paths for all se
 * accelerometers, and temperature sensor). This operation wi	 * accelerometers, and temperature sensor). This operation wi
 * sensor registers. This bit automatically clears to 0 after	 * sensor registers. This bit automatically clears to 0 after
 * triggered.							 * triggered.
 *								 *
 * When resetting only the signal path (and not the sensor re	 * When resetting only the signal path (and not the sensor re
 * use Register 104, SIGNAL_PATH_RESET.				 * use Register 104, SIGNAL_PATH_RESET.
 *								 *
 * @see MPU6050_RA_USER_CTRL					 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_SIG_COND_RESET_BIT			 * @see MPU6050_USERCTRL_SIG_COND_RESET_BIT
 */								 */
void MPU6050_resetSensors()				      |	void MPU6050_resetSensors() {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL <
	                MPU6050_USERCTRL_SIG_COND_RESET_BIT,  <
}								}

// PWR_MGMT_1 register						// PWR_MGMT_1 register

/** Trigger a full device reset.				/** Trigger a full device reset.
 * A small delay of ~50ms may be desirable after triggering a	 * A small delay of ~50ms may be desirable after triggering a
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_DEVICE_RESET_BIT				 * @see MPU6050_PWR1_DEVICE_RESET_BIT
 */								 */
void MPU6050_reset()					      |	void MPU6050_reset() {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR1_DEVICE_RESET_BIT, true); <
}								}
/** Get sleep mode status.					/** Get sleep mode status.
 * Setting the SLEEP bit in the register puts the device into	 * Setting the SLEEP bit in the register puts the device into
 * sleep mode. In this mode, only the serial interface and in	 * sleep mode. In this mode, only the serial interface and in
 * remain active, allowing for a very low standby current. Cl	 * remain active, allowing for a very low standby current. Cl
 * puts the device back into normal mode. To save power, the 	 * puts the device back into normal mode. To save power, the 
 * selections for each of the gyros should be used if any gyr	 * selections for each of the gyros should be used if any gyr
 * by the application.						 * by the application.
 * @return Current sleep mode enabled status			 * @return Current sleep mode enabled status
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_SLEEP_BIT					 * @see MPU6050_PWR1_SLEEP_BIT
 */								 */
bool MPU6050_getSleepEnabled()				      |	bool MPU6050_getSleepEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set sleep mode status.					/** Set sleep mode status.
 * @param enabled New sleep mode enabled status			 * @param enabled New sleep mode enabled status
 * @see getSleepEnabled()					 * @see getSleepEnabled()
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_SLEEP_BIT					 * @see MPU6050_PWR1_SLEEP_BIT
 */								 */
void MPU6050_setSleepEnabled(bool enabled)		      |	void MPU6050_setSleepEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                enabled);			      <
}								}
/** Get wake cycle enabled status.				/** Get wake cycle enabled status.
 * When this bit is set to 1 and SLEEP is disabled, the MPU-6	 * When this bit is set to 1 and SLEEP is disabled, the MPU-6
 * between sleep mode and waking up to take a single sample o	 * between sleep mode and waking up to take a single sample o
 * sensors at a rate determined by LP_WAKE_CTRL (register 108	 * sensors at a rate determined by LP_WAKE_CTRL (register 108
 * @return Current sleep mode enabled status			 * @return Current sleep mode enabled status
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CYCLE_BIT					 * @see MPU6050_PWR1_CYCLE_BIT
 */								 */
bool MPU6050_getWakeCycleEnabled()			      |	bool MPU6050_getWakeCycleEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set wake cycle enabled status.				/** Set wake cycle enabled status.
 * @param enabled New sleep mode enabled status			 * @param enabled New sleep mode enabled status
 * @see getWakeCycleEnabled()					 * @see getWakeCycleEnabled()
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CYCLE_BIT					 * @see MPU6050_PWR1_CYCLE_BIT
 */								 */
void MPU6050_setWakeCycleEnabled(bool enabled)		      |	void MPU6050_setWakeCycleEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                enabled);			      <
}								}
/** Get temperature sensor enabled status.			/** Get temperature sensor enabled status.
 * Control the usage of the internal temperature sensor.	 * Control the usage of the internal temperature sensor.
 *								 *
 * Note: this register stores the *disabled* value, but for c	 * Note: this register stores the *disabled* value, but for c
 * rest of the code, the function is named and used with stan	 * rest of the code, the function is named and used with stan
 * values to indicate whether the sensor is enabled or disabl	 * values to indicate whether the sensor is enabled or disabl
 *								 *
 * @return Current temperature sensor enabled status		 * @return Current temperature sensor enabled status
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_TEMP_DIS_BIT				 * @see MPU6050_PWR1_TEMP_DIS_BIT
 */								 */
bool MPU6050_getTempSensorEnabled()			      |	bool MPU6050_getTempSensorEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1 |	    return mpu6050.buffer[0] == 0; // 1 is actually disabled 
	               MPU6050_PWR1_TEMP_DIS_BIT, mpu6050.buf <
	return mpu6050.buffer[0] == 0; // 1 is actually disab <
}								}
/** Set temperature sensor enabled status.			/** Set temperature sensor enabled status.
 * Note: this register stores the *disabled* value, but for c	 * Note: this register stores the *disabled* value, but for c
 * rest of the code, the function is named and used with stan	 * rest of the code, the function is named and used with stan
 * values to indicate whether the sensor is enabled or disabl	 * values to indicate whether the sensor is enabled or disabl
 *								 *
 * @param enabled New temperature sensor enabled status		 * @param enabled New temperature sensor enabled status
 * @see getTempSensorEnabled()					 * @see getTempSensorEnabled()
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_TEMP_DIS_BIT				 * @see MPU6050_PWR1_TEMP_DIS_BIT
 */								 */
void MPU6050_setTempSensorEnabled(bool enabled)		      |	void MPU6050_setTempSensorEnabled(bool enabled) {
{							      |	    // 1 is actually disabled here
	// 1 is actually disabled here			      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR1_TEMP_DIS_BIT, !enabled); <
}								}
/** Get clock source setting.					/** Get clock source setting.
 * @return Current clock source setting				 * @return Current clock source setting
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CLKSEL_BIT					 * @see MPU6050_PWR1_CLKSEL_BIT
 * @see MPU6050_PWR1_CLKSEL_LENGTH				 * @see MPU6050_PWR1_CLKSEL_LENGTH
 */								 */
uint8_t MPU6050_getClockSource()			      |	uint8_t MPU6050_getClockSource() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, M
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ |	    return mpu6050.buffer[0];
	                MPU6050_PWR1_CLKSEL_LENGTH, mpu6050.b <
	return mpu6050.buffer[0];			      <
}								}
/** Set clock source setting.					/** Set clock source setting.
 * An internal 8MHz oscillator, gyroscope based clock, or ext	 * An internal 8MHz oscillator, gyroscope based clock, or ext
 * be selected as the MPU-60X0 clock source. When the interna	 * be selected as the MPU-60X0 clock source. When the interna
 * or an external source is chosen as the clock source, the M	 * or an external source is chosen as the clock source, the M
 * in low power modes with the gyroscopes disabled.		 * in low power modes with the gyroscopes disabled.
 *								 *
 * Upon power up, the MPU-60X0 clock source defaults to the i	 * Upon power up, the MPU-60X0 clock source defaults to the i
 * However, it is highly recommended that the device be confi	 * However, it is highly recommended that the device be confi
 * the gyroscopes (or an external clock source) as the clock 	 * the gyroscopes (or an external clock source) as the clock 
 * improved stability. The clock source can be selected accor	 * improved stability. The clock source can be selected accor
 *								 *
 * <pre>							 * <pre>
 * CLK_SEL | Clock Source					 * CLK_SEL | Clock Source
 * --------+--------------------------------------		 * --------+--------------------------------------
 * 0       | Internal oscillator				 * 0       | Internal oscillator
 * 1       | PLL with X Gyro reference				 * 1       | PLL with X Gyro reference
 * 2       | PLL with Y Gyro reference				 * 2       | PLL with Y Gyro reference
 * 3       | PLL with Z Gyro reference				 * 3       | PLL with Z Gyro reference
 * 4       | PLL with external 32.768kHz reference		 * 4       | PLL with external 32.768kHz reference
 * 5       | PLL with external 19.2MHz reference		 * 5       | PLL with external 19.2MHz reference
 * 6       | Reserved						 * 6       | Reserved
 * 7       | Stops the clock and keeps the timing generator i	 * 7       | Stops the clock and keeps the timing generator i
 * </pre>							 * </pre>
 *								 *
 * @param source New clock source setting			 * @param source New clock source setting
 * @see getClockSource()					 * @see getClockSource()
 * @see MPU6050_RA_PWR_MGMT_1					 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CLKSEL_BIT					 * @see MPU6050_PWR1_CLKSEL_BIT
 * @see MPU6050_PWR1_CLKSEL_LENGTH				 * @see MPU6050_PWR1_CLKSEL_LENGTH
 */								 */
void MPU6050_setClockSource(uint8_t source)		      |	void MPU6050_setClockSource(uint8_t source) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_1, 
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT <
	                 MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR <
}								}

// PWR_MGMT_2 register						// PWR_MGMT_2 register

/** Get wake frequency in Accel-Only Low Power Mode.		/** Get wake frequency in Accel-Only Low Power Mode.
 * The MPU-60X0 can be put into Accerlerometer Only Low Power	 * The MPU-60X0 can be put into Accerlerometer Only Low Power
 * PWRSEL to 1 in the Power Management 1 register (Register 1	 * PWRSEL to 1 in the Power Management 1 register (Register 1
 * the device will power off all devices except for the prima	 * the device will power off all devices except for the prima
 * waking only the accelerometer at fixed intervals to take a	 * waking only the accelerometer at fixed intervals to take a
 * measurement. The frequency of wake-ups can be configured w	 * measurement. The frequency of wake-ups can be configured w
 * as shown below:						 * as shown below:
 *								 *
 * <pre>							 * <pre>
 * LP_WAKE_CTRL | Wake-up Frequency				 * LP_WAKE_CTRL | Wake-up Frequency
 * -------------+------------------				 * -------------+------------------
 * 0            | 1.25 Hz					 * 0            | 1.25 Hz
 * 1            | 2.5 Hz					 * 1            | 2.5 Hz
 * 2            | 5 Hz						 * 2            | 5 Hz
 * 3            | 10 Hz						 * 3            | 10 Hz
 * <pre>							 * <pre>
 *								 *
 * For further information regarding the MPU-60X0's power mod	 * For further information regarding the MPU-60X0's power mod
 * Register 107.						 * Register 107.
 *								 *
 * @return Current wake frequency				 * @return Current wake frequency
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 */								 */
uint8_t MPU6050_getWakeFrequency()			      |	uint8_t MPU6050_getWakeFrequency() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, M
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ |	    return mpu6050.buffer[0];
	                MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU605 <
	                mpu6050.buffer);		      <
	return mpu6050.buffer[0];			      <
}								}
/** Set wake frequency in Accel-Only Low Power Mode.		/** Set wake frequency in Accel-Only Low Power Mode.
 * @param frequency New wake frequency				 * @param frequency New wake frequency
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 */								 */
void MPU6050_setWakeFrequency(uint8_t frequency)	      |	void MPU6050_setWakeFrequency(uint8_t frequency) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, 
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_PWR_MGMT <
	                 MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU60 <
}								}

/** Get X-axis accelerometer standby enabled status.		/** Get X-axis accelerometer standby enabled status.
 * If enabled, the X-axis will not gather or report data (or 	 * If enabled, the X-axis will not gather or report data (or 
 * @return Current X-axis standby enabled status		 * @return Current X-axis standby enabled status
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_XA_BIT				 * @see MPU6050_PWR2_STBY_XA_BIT
 */								 */
bool MPU6050_getStandbyXAccelEnabled()			      |	bool MPU6050_getStandbyXAccelEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set X-axis accelerometer standby enabled status.		/** Set X-axis accelerometer standby enabled status.
 * @param New X-axis standby enabled status			 * @param New X-axis standby enabled status
 * @see getStandbyXAccelEnabled()				 * @see getStandbyXAccelEnabled()
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_XA_BIT				 * @see MPU6050_PWR2_STBY_XA_BIT
 */								 */
void MPU6050_setStandbyXAccelEnabled(bool enabled)	      |	void MPU6050_setStandbyXAccelEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR2_STBY_XA_BIT, enabled);   <
}								}
/** Get Y-axis accelerometer standby enabled status.		/** Get Y-axis accelerometer standby enabled status.
 * If enabled, the Y-axis will not gather or report data (or 	 * If enabled, the Y-axis will not gather or report data (or 
 * @return Current Y-axis standby enabled status		 * @return Current Y-axis standby enabled status
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_YA_BIT				 * @see MPU6050_PWR2_STBY_YA_BIT
 */								 */
bool MPU6050_getStandbyYAccelEnabled()			      |	bool MPU6050_getStandbyYAccelEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Y-axis accelerometer standby enabled status.		/** Set Y-axis accelerometer standby enabled status.
 * @param New Y-axis standby enabled status			 * @param New Y-axis standby enabled status
 * @see getStandbyYAccelEnabled()				 * @see getStandbyYAccelEnabled()
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_YA_BIT				 * @see MPU6050_PWR2_STBY_YA_BIT
 */								 */
void MPU6050_setStandbyYAccelEnabled(bool enabled)	      |	void MPU6050_setStandbyYAccelEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR2_STBY_YA_BIT, enabled);   <
}								}
/** Get Z-axis accelerometer standby enabled status.		/** Get Z-axis accelerometer standby enabled status.
 * If enabled, the Z-axis will not gather or report data (or 	 * If enabled, the Z-axis will not gather or report data (or 
 * @return Current Z-axis standby enabled status		 * @return Current Z-axis standby enabled status
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_ZA_BIT				 * @see MPU6050_PWR2_STBY_ZA_BIT
 */								 */
bool MPU6050_getStandbyZAccelEnabled()			      |	bool MPU6050_getStandbyZAccelEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Z-axis accelerometer standby enabled status.		/** Set Z-axis accelerometer standby enabled status.
 * @param New Z-axis standby enabled status			 * @param New Z-axis standby enabled status
 * @see getStandbyZAccelEnabled()				 * @see getStandbyZAccelEnabled()
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_ZA_BIT				 * @see MPU6050_PWR2_STBY_ZA_BIT
 */								 */
void MPU6050_setStandbyZAccelEnabled(bool enabled)	      |	void MPU6050_setStandbyZAccelEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR2_STBY_ZA_BIT, enabled);   <
}								}
/** Get X-axis gyroscope standby enabled status.		/** Get X-axis gyroscope standby enabled status.
 * If enabled, the X-axis will not gather or report data (or 	 * If enabled, the X-axis will not gather or report data (or 
 * @return Current X-axis standby enabled status		 * @return Current X-axis standby enabled status
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_XG_BIT				 * @see MPU6050_PWR2_STBY_XG_BIT
 */								 */
bool MPU6050_getStandbyXGyroEnabled()			      |	bool MPU6050_getStandbyXGyroEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set X-axis gyroscope standby enabled status.		/** Set X-axis gyroscope standby enabled status.
 * @param New X-axis standby enabled status			 * @param New X-axis standby enabled status
 * @see getStandbyXGyroEnabled()				 * @see getStandbyXGyroEnabled()
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_XG_BIT				 * @see MPU6050_PWR2_STBY_XG_BIT
 */								 */
void MPU6050_setStandbyXGyroEnabled(bool enabled)	      |	void MPU6050_setStandbyXGyroEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR2_STBY_XG_BIT, enabled);   <
}								}
/** Get Y-axis gyroscope standby enabled status.		/** Get Y-axis gyroscope standby enabled status.
 * If enabled, the Y-axis will not gather or report data (or 	 * If enabled, the Y-axis will not gather or report data (or 
 * @return Current Y-axis standby enabled status		 * @return Current Y-axis standby enabled status
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_YG_BIT				 * @see MPU6050_PWR2_STBY_YG_BIT
 */								 */
bool MPU6050_getStandbyYGyroEnabled()			      |	bool MPU6050_getStandbyYGyroEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Y-axis gyroscope standby enabled status.		/** Set Y-axis gyroscope standby enabled status.
 * @param New Y-axis standby enabled status			 * @param New Y-axis standby enabled status
 * @see getStandbyYGyroEnabled()				 * @see getStandbyYGyroEnabled()
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_YG_BIT				 * @see MPU6050_PWR2_STBY_YG_BIT
 */								 */
void MPU6050_setStandbyYGyroEnabled(bool enabled)	      |	void MPU6050_setStandbyYGyroEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR2_STBY_YG_BIT, enabled);   <
}								}
/** Get Z-axis gyroscope standby enabled status.		/** Get Z-axis gyroscope standby enabled status.
 * If enabled, the Z-axis will not gather or report data (or 	 * If enabled, the Z-axis will not gather or report data (or 
 * @return Current Z-axis standby enabled status		 * @return Current Z-axis standby enabled status
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_ZG_BIT				 * @see MPU6050_PWR2_STBY_ZG_BIT
 */								 */
bool MPU6050_getStandbyZGyroEnabled()			      |	bool MPU6050_getStandbyZGyroEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2 |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}
/** Set Z-axis gyroscope standby enabled status.		/** Set Z-axis gyroscope standby enabled status.
 * @param New Z-axis standby enabled status			 * @param New Z-axis standby enabled status
 * @see getStandbyZGyroEnabled()				 * @see getStandbyZGyroEnabled()
 * @see MPU6050_RA_PWR_MGMT_2					 * @see MPU6050_RA_PWR_MGMT_2
 * @see MPU6050_PWR2_STBY_ZG_BIT				 * @see MPU6050_PWR2_STBY_ZG_BIT
 */								 */
void MPU6050_setStandbyZGyroEnabled(bool enabled)	      |	void MPU6050_setStandbyZGyroEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_2, M
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_PWR_MGMT_ <
	                MPU6050_PWR2_STBY_ZG_BIT, enabled);   <
}								}

// FIFO_COUNT* registers					// FIFO_COUNT* registers

/** Get current FIFO mpu6050.buffer size.			/** Get current FIFO mpu6050.buffer size.
 * This value indicates the number of bytes stored in the FIF	 * This value indicates the number of bytes stored in the FIF
 * number is in turn the number of bytes that can be read fro	 * number is in turn the number of bytes that can be read fro
 * and it is directly proportional to the number of samples a	 * and it is directly proportional to the number of samples a
 * set of sensor data bound to be stored in the FIFO (registe	 * set of sensor data bound to be stored in the FIFO (registe
 * @return Current FIFO mpu6050.buffer size			 * @return Current FIFO mpu6050.buffer size
 */								 */
uint16_t MPU6050_getFIFOCount()				      |	uint16_t MPU6050_getFIFOCount() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_FIFO_COUNTH,
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_FIFO_COU |	    return (((uint16_t)mpu6050.buffer[0]) << 8) | mpu6050.buf
	return (((uint16_t)mpu6050.buffer[0]) << 8) | mpu6050 <
}								}

// FIFO_R_W register						// FIFO_R_W register

/** Get byte from FIFO mpu6050.buffer.				/** Get byte from FIFO mpu6050.buffer.
 * This register is used to read and write data from the FIFO	 * This register is used to read and write data from the FIFO
 * written to the FIFO in order of register number (from lowe	 * written to the FIFO in order of register number (from lowe
 * all the FIFO enable flags (see below) are enabled and all 	 * all the FIFO enable flags (see below) are enabled and all 
 * Data registers (Registers 73 to 96) are associated with a 	 * Data registers (Registers 73 to 96) are associated with a 
 * contents of registers 59 through 96 will be written in ord	 * contents of registers 59 through 96 will be written in ord
 * Rate.							 * Rate.
 *								 *
 * The contents of the sensor data registers (Registers 59 to	 * The contents of the sensor data registers (Registers 59 to
 * into the FIFO mpu6050.buffer when their corresponding FIFO	 * into the FIFO mpu6050.buffer when their corresponding FIFO
 * in FIFO_EN (Register 35). An additional flag for the senso	 * in FIFO_EN (Register 35). An additional flag for the senso
 * associated with I2C Slave 3 can be found in I2C_MST_CTRL (	 * associated with I2C Slave 3 can be found in I2C_MST_CTRL (
 *								 *
 * If the FIFO mpu6050.buffer has overflowed, the status bit 	 * If the FIFO mpu6050.buffer has overflowed, the status bit 
 * automatically set to 1. This bit is located in INT_STATUS 	 * automatically set to 1. This bit is located in INT_STATUS 
 * When the FIFO mpu6050.buffer has overflowed, the oldest da	 * When the FIFO mpu6050.buffer has overflowed, the oldest da
 * data will be written to the FIFO.				 * data will be written to the FIFO.
 *								 *
 * If the FIFO mpu6050.buffer is empty, reading this register	 * If the FIFO mpu6050.buffer is empty, reading this register
 * that was previously read from the FIFO until new data is a	 * that was previously read from the FIFO until new data is a
 * should check FIFO_COUNT to ensure that the FIFO mpu6050.bu	 * should check FIFO_COUNT to ensure that the FIFO mpu6050.bu
 * empty.							 * empty.
 *								 *
 * @return Byte from FIFO mpu6050.buffer			 * @return Byte from FIFO mpu6050.buffer
 */								 */
uint8_t MPU6050_getFIFOByte()				      |	uint8_t MPU6050_getFIFOByte() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_FIFO_R_W, mpu
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_FIFO_R_W, |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      |	}
}							      |	void MPU6050_getFIFOBytes(uint8_t *data, uint8_t length) {
void MPU6050_getFIFOBytes(uint8_t *data, uint8_t length)      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_FIFO_R_W, le
{							      <
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_FIFO_R_W <
}								}
/** Write byte to FIFO mpu6050.buffer.				/** Write byte to FIFO mpu6050.buffer.
 * @see getFIFOByte()						 * @see getFIFOByte()
 * @see MPU6050_RA_FIFO_R_W					 * @see MPU6050_RA_FIFO_R_W
 */								 */
void MPU6050_setFIFOByte(uint8_t data)			      |	void MPU6050_setFIFOByte(uint8_t data) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_FIFO_R_W, da
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_FIFO_R_W <
}								}

// WHO_AM_I register						// WHO_AM_I register

/** Get Device ID.						/** Get Device ID.
 * This register is used to verify the identity of the device	 * This register is used to verify the identity of the device
 * @return Device ID (6 bits only! should be 0x34)		 * @return Device ID (6 bits only! should be 0x34)
 * @see MPU6050_RA_WHO_AM_I					 * @see MPU6050_RA_WHO_AM_I
 * @see MPU6050_WHO_AM_I_BIT					 * @see MPU6050_WHO_AM_I_BIT
 * @see MPU6050_WHO_AM_I_LENGTH					 * @see MPU6050_WHO_AM_I_LENGTH
 */								 */
uint8_t MPU6050_getDeviceID()				      |	uint8_t MPU6050_getDeviceID() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_WHO_AM_I, MPU
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_WHO_AM_I, |	    return mpu6050.buffer[0];
	                MPU6050_WHO_AM_I_LENGTH, mpu6050.buff <
	return mpu6050.buffer[0];			      <
}								}
/** Set Device ID.						/** Set Device ID.
 * Write a new ID into the WHO_AM_I register (no idea why thi	 * Write a new ID into the WHO_AM_I register (no idea why thi
 * necessary though).						 * necessary though).
 * @param id New device ID to set.				 * @param id New device ID to set.
 * @see getDeviceID()						 * @see getDeviceID()
 * @see MPU6050_RA_WHO_AM_I					 * @see MPU6050_RA_WHO_AM_I
 * @see MPU6050_WHO_AM_I_BIT					 * @see MPU6050_WHO_AM_I_BIT
 * @see MPU6050_WHO_AM_I_LENGTH					 * @see MPU6050_WHO_AM_I_LENGTH
 */								 */
void MPU6050_setDeviceID(uint8_t id)			      |	void MPU6050_setDeviceID(uint8_t id) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_WHO_AM_I, MP
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_WHO_AM_I <
	                 MPU6050_WHO_AM_I_LENGTH, id);	      <
}								}

// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========		// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========

// XG_OFFS_TC register						// XG_OFFS_TC register

uint8_t MPU6050_getOTPBankValid()			      |	uint8_t MPU6050_getOTPBankValid() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_XG_OFFS_TC, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_XG_OFFS_TC |	    return mpu6050.buffer[0];
	               MPU6050_TC_OTP_BNK_VLD_BIT, mpu6050.bu |	}
	return mpu6050.buffer[0];			      |	void MPU6050_setOTPBankValid(bool enabled) {
}							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_XG_OFFS_TC, M
void MPU6050_setOTPBankValid(bool enabled)		      |	}
{							      |	int8_t MPU6050_getXGyroOffsetTC() {
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_XG_OFFS_T |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_XG_OFFS_TC, M
	                MPU6050_TC_OTP_BNK_VLD_BIT, enabled); |	    return mpu6050.buffer[0];
}							      |	}
int8_t MPU6050_getXGyroOffsetTC()			      |	void MPU6050_setXGyroOffsetTC(int8_t offset) {
{							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_XG_OFFS_TC, 
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_XG_OFFS_T <
	                MPU6050_TC_OFFSET_LENGTH, mpu6050.buf <
	return mpu6050.buffer[0];			      <
}							      <
void MPU6050_setXGyroOffsetTC(int8_t offset)		      <
{							      <
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_XG_OFFS_ <
	                 MPU6050_TC_OFFSET_LENGTH, offset);   <
}								}

// YG_OFFS_TC register						// YG_OFFS_TC register

int8_t MPU6050_getYGyroOffsetTC()			      |	int8_t MPU6050_getYGyroOffsetTC() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_YG_OFFS_TC, M
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_YG_OFFS_T |	    return mpu6050.buffer[0];
	                MPU6050_TC_OFFSET_LENGTH, mpu6050.buf |	}
	return mpu6050.buffer[0];			      |	void MPU6050_setYGyroOffsetTC(int8_t offset) {
}							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_YG_OFFS_TC, 
void MPU6050_setYGyroOffsetTC(int8_t offset)		      <
{							      <
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_YG_OFFS_ <
	                 MPU6050_TC_OFFSET_LENGTH, offset);   <
}								}

// ZG_OFFS_TC register						// ZG_OFFS_TC register

int8_t MPU6050_getZGyroOffsetTC()			      |	int8_t MPU6050_getZGyroOffsetTC() {
{							      |	    I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_TC, M
	I2Cdev_readBits(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_T |	    return mpu6050.buffer[0];
	                MPU6050_TC_OFFSET_LENGTH, mpu6050.buf |	}
	return mpu6050.buffer[0];			      |	void MPU6050_setZGyroOffsetTC(int8_t offset) {
}							      |	    I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_TC, 
void MPU6050_setZGyroOffsetTC(int8_t offset)		      <
{							      <
	I2Cdev_writeBits(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_ <
	                 MPU6050_TC_OFFSET_LENGTH, offset);   <
}								}

// X_FINE_GAIN register						// X_FINE_GAIN register

int8_t MPU6050_getXFineGain()				      |	int8_t MPU6050_getXFineGain() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_X_FINE_GAIN, 
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_X_FINE_GA |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      |	}
}							      |	void MPU6050_setXFineGain(int8_t gain) {
void MPU6050_setXFineGain(int8_t gain)			      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_X_FINE_GAIN,
{							      <
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_X_FINE_G <
}								}

// Y_FINE_GAIN register						// Y_FINE_GAIN register

int8_t MPU6050_getYFineGain()				      |	int8_t MPU6050_getYFineGain() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_Y_FINE_GAIN, 
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_Y_FINE_GA |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      |	}
}							      |	void MPU6050_setYFineGain(int8_t gain) {
void MPU6050_setYFineGain(int8_t gain)			      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_Y_FINE_GAIN,
{							      <
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_Y_FINE_G <
}								}

// Z_FINE_GAIN register						// Z_FINE_GAIN register

int8_t MPU6050_getZFineGain()				      |	int8_t MPU6050_getZFineGain() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_Z_FINE_GAIN, 
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_Z_FINE_GA |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      |	}
}							      |	void MPU6050_setZFineGain(int8_t gain) {
void MPU6050_setZFineGain(int8_t gain)			      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_Z_FINE_GAIN,
{							      <
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_Z_FINE_G <
}								}

// XA_OFFS_* registers						// XA_OFFS_* registers

int16_t MPU6050_getXAccelOffset()			      |	int16_t MPU6050_getXAccelOffset() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_XA_OFFS_H, 2
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_XA_OFFS_ |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. |	}
}							      |	void MPU6050_setXAccelOffset(int16_t offset) {
void MPU6050_setXAccelOffset(int16_t offset)		      |	    I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_XA_OFFS_H, o
{							      <
	I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_XA_OFFS_ <
}								}

// YA_OFFS_* register						// YA_OFFS_* register

int16_t MPU6050_getYAccelOffset()			      |	int16_t MPU6050_getYAccelOffset() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_YA_OFFS_H, 2
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_YA_OFFS_ |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. |	}
}							      |	void MPU6050_setYAccelOffset(int16_t offset) {
void MPU6050_setYAccelOffset(int16_t offset)		      |	    I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_YA_OFFS_H, o
{							      <
	I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_YA_OFFS_ <
}								}

// ZA_OFFS_* register						// ZA_OFFS_* register

int16_t MPU6050_getZAccelOffset()			      |	int16_t MPU6050_getZAccelOffset() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ZA_OFFS_H, 2
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ZA_OFFS_ |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. |	}
}							      |	void MPU6050_setZAccelOffset(int16_t offset) {
void MPU6050_setZAccelOffset(int16_t offset)		      |	    I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_ZA_OFFS_H, o
{							      <
	I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_ZA_OFFS_ <
}								}

// XG_OFFS_USR* registers					// XG_OFFS_USR* registers

int16_t MPU6050_getXGyroOffset()			      |	int16_t MPU6050_getXGyroOffset() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_XG_OFFS_USRH
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_XG_OFFS_ |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. |	}
}							      |	void MPU6050_setXGyroOffset(int16_t offset) {
void MPU6050_setXGyroOffset(int16_t offset)		      |	    I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_XG_OFFS_USRH
{							      <
	I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_XG_OFFS_ <
}								}

// YG_OFFS_USR* register					// YG_OFFS_USR* register

int16_t MPU6050_getYGyroOffset()			      |	int16_t MPU6050_getYGyroOffset() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_YG_OFFS_USRH
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_YG_OFFS_ |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. |	}
}							      |	void MPU6050_setYGyroOffset(int16_t offset) {
void MPU6050_setYGyroOffset(int16_t offset)		      |	    I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_YG_OFFS_USRH
{							      <
	I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_YG_OFFS_ <
}								}

// ZG_OFFS_USR* register					// ZG_OFFS_USR* register

int16_t MPU6050_getZGyroOffset()			      |	int16_t MPU6050_getZGyroOffset() {
{							      |	    I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_USRH
	I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_ |	    return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050.buff
	return (((int16_t)mpu6050.buffer[0]) << 8) | mpu6050. |	}
}							      |	void MPU6050_setZGyroOffset(int16_t offset) {
void MPU6050_setZGyroOffset(int16_t offset)		      |	    I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_USRH
{							      <
	I2Cdev_writeWord(mpu6050.devAddr, MPU6050_RA_ZG_OFFS_ <
}								}

// INT_ENABLE register (DMP functions)				// INT_ENABLE register (DMP functions)

bool MPU6050_getIntPLLReadyEnabled()			      |	bool MPU6050_getIntPLLReadyEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_PLL_RDY_INT_BIT, mpu |	}
	return mpu6050.buffer[0];			      |	void MPU6050_setIntPLLReadyEnabled(bool enabled) {
}							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
void MPU6050_setIntPLLReadyEnabled(bool enabled)	      |	}
{							      |	bool MPU6050_getIntDMPEnabled() {
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, MP
	                MPU6050_INTERRUPT_PLL_RDY_INT_BIT, en |	    return mpu6050.buffer[0];
}							      |	}
bool MPU6050_getIntDMPEnabled()				      |	void MPU6050_setIntDMPEnabled(bool enabled) {
{							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE, M
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_ENABLE <
	               MPU6050_INTERRUPT_DMP_INT_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}							      <
void MPU6050_setIntDMPEnabled(bool enabled)		      <
{							      <
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_INT_ENABL <
	                MPU6050_INTERRUPT_DMP_INT_BIT, enable <
}								}

// DMP_INT_STATUS						// DMP_INT_STATUS

bool MPU6050_getDMPInt5Status()				      |	bool MPU6050_getDMPInt5Status() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_ST |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      |	}
	return mpu6050.buffer[0];			      |	bool MPU6050_getDMPInt4Status() {
}							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_STATUS
bool MPU6050_getDMPInt4Status()				      |	    return mpu6050.buffer[0];
{							      |	}
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_ST |	bool MPU6050_getDMPInt3Status() {
	               mpu6050.buffer);			      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_STATUS
	return mpu6050.buffer[0];			      |	    return mpu6050.buffer[0];
}							      |	}
bool MPU6050_getDMPInt3Status()				      |	bool MPU6050_getDMPInt2Status() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_STATUS
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_ST |	    return mpu6050.buffer[0];
	               mpu6050.buffer);			      |	}
	return mpu6050.buffer[0];			      |	bool MPU6050_getDMPInt1Status() {
}							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_STATUS
bool MPU6050_getDMPInt2Status()				      |	    return mpu6050.buffer[0];
{							      |	}
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_ST |	bool MPU6050_getDMPInt0Status() {
	               mpu6050.buffer);			      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_STATUS
	return mpu6050.buffer[0];			      |	    return mpu6050.buffer[0];
}							      <
bool MPU6050_getDMPInt1Status()				      <
{							      <
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_ST <
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}							      <
bool MPU6050_getDMPInt0Status()				      <
{							      <
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_DMP_INT_ST <
	               mpu6050.buffer);			      <
	return mpu6050.buffer[0];			      <
}								}

// INT_STATUS register (DMP functions)				// INT_STATUS register (DMP functions)

bool MPU6050_getIntPLLReadyStatus()			      |	bool MPU6050_getIntPLLReadyStatus() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS |	    return mpu6050.buffer[0];
	               MPU6050_INTERRUPT_PLL_RDY_INT_BIT, mpu |	}
	return mpu6050.buffer[0];			      |	bool MPU6050_getIntDMPStatus() {
}							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS, MP
bool MPU6050_getIntDMPStatus()				      |	    return mpu6050.buffer[0];
{							      <
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_INT_STATUS <
	               MPU6050_INTERRUPT_DMP_INT_BIT, mpu6050 <
	return mpu6050.buffer[0];			      <
}								}

// USER_CTRL register (DMP functions)				// USER_CTRL register (DMP functions)

bool MPU6050_getDMPEnabled()				      |	bool MPU6050_getDMPEnabled() {
{							      |	    I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MPU
	I2Cdev_readBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, |	    return mpu6050.buffer[0];
	               MPU6050_USERCTRL_DMP_EN_BIT, mpu6050.b |	}
	return mpu6050.buffer[0];			      |	void MPU6050_setDMPEnabled(bool enabled) {
}							      |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
void MPU6050_setDMPEnabled(bool enabled)		      |	}
{							      |	void MPU6050_resetDMP() {
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL |	    I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL, MP
	                MPU6050_USERCTRL_DMP_EN_BIT, enabled) <
}							      <
void MPU6050_resetDMP()					      <
{							      <
	I2Cdev_writeBit(mpu6050.devAddr, MPU6050_RA_USER_CTRL <
	                MPU6050_USERCTRL_DMP_RESET_BIT, true) <
}								}

// BANK_SEL register						// BANK_SEL register

void MPU6050_setMemoryBank(uint8_t bank, bool prefetchEnabled |	void MPU6050_setMemoryBank(uint8_t bank, bool prefetchEnabled
{							      |	    bank &= 0x1F;
	bank &= 0x1F;					      |	    if (userBank) bank |= 0x20;
	if (userBank) bank |= 0x20;			      |	    if (prefetchEnabled) bank |= 0x40;
	if (prefetchEnabled) bank |= 0x40;		      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_BANK_SEL, ba
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_BANK_SEL <
}								}

// MEM_START_ADDR register					// MEM_START_ADDR register

void MPU6050_setMemoryStartAddress(uint8_t address)	      |	void MPU6050_setMemoryStartAddress(uint8_t address) {
{							      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MEM_START_AD
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MEM_STAR <
}								}

// MEM_R_W register						// MEM_R_W register

uint8_t MPU6050_readMemoryByte()			      |	uint8_t MPU6050_readMemoryByte() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_MEM_R_W, mpu6
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_MEM_R_W,  |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      |	}
}							      |	void MPU6050_writeMemoryByte(uint8_t data) {
void MPU6050_writeMemoryByte(uint8_t data)		      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MEM_R_W, dat
{							      |	}
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_MEM_R_W, |	void MPU6050_readMemoryBlock(uint8_t *data, uint16_t dataSize
}							      |	    MPU6050_setMemoryBank(bank, false, false);
void MPU6050_readMemoryBlock(uint8_t *data, uint16_t dataSize |	    MPU6050_setMemoryStartAddress(address);
                             uint8_t address)		      |	    uint8_t chunkSize;
{							      |	    uint16_t i;
	MPU6050_setMemoryBank(bank, false, false);	      <
	MPU6050_setMemoryStartAddress(address);		      <
	uint8_t chunkSize;				      <
	uint16_t i;					      <
    for (i = 0; i < dataSize;) {				    for (i = 0; i < dataSize;) {
		// determine correct chunk size according to  |	        // determine correct chunk size according to bank pos
		chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;    |	        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;
							      >
							      >	        // make sure we don't go past the data size
							      >	        if (i + chunkSize > dataSize) chunkSize = dataSize - 
							      >
							      >	        // make sure this chunk doesn't go past the bank boun
							      >	        if (chunkSize > 256 - address) chunkSize = 256 - addr

		// make sure we don't go past the data size   |	        // read the chunk of data as specified
		if (i + chunkSize > dataSize) chunkSize = dat |	        I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_MEM_R_W,
							      >	        
							      >	        // increase byte index by [chunkSize]
							      >	        i += chunkSize;

		// make sure this chunk doesn't go past the b |	        // uint8_t automatically wraps to 0 at 256
		if (chunkSize > 256 - address) chunkSize = 25 |	        address += chunkSize;

		// read the chunk of data as specified	      |	        // if we aren't done, update bank (if necessary) and 
		I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_ |	        if (i < dataSize) {
							      |	            if (address == 0) bank++;
		// increase byte index by [chunkSize]	      |	            MPU6050_setMemoryBank(bank, false, false);
		i += chunkSize;				      |	            MPU6050_setMemoryStartAddress(address);
							      |	        }
		// uint8_t automatically wraps to 0 at 256    |	    }
		address += chunkSize;			      <
							      <
		// if we aren't done, update bank (if necessa <
		if (i < dataSize) {			      <
			if (address == 0) bank++;	      <
			MPU6050_setMemoryBank(bank, false, fa <
			MPU6050_setMemoryStartAddress(address <
		}					      <
	}						      <
}								}
/*bool MPU6050_writeMemoryBlock(const uint8_t *data, uint16_t	/*bool MPU6050_writeMemoryBlock(const uint8_t *data, uint16_t
    MPU6050_setMemoryBank(bank, false, false);			    MPU6050_setMemoryBank(bank, false, false);
    MPU6050_setMemoryStartAddress(address);			    MPU6050_setMemoryStartAddress(address);
    uint8_t chunkSize;						    uint8_t chunkSize;
    uint8_t *verifyBuffer;					    uint8_t *verifyBuffer;
    uint8_t *progBuffer;					    uint8_t *progBuffer;
    uint16_t i;							    uint16_t i;
    uint8_t j;							    uint8_t j;
    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_	    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_
    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DM	    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DM
    for (i = 0; i < dataSize;) {				    for (i = 0; i < dataSize;) {
        // determine correct chunk size according to bank pos	        // determine correct chunk size according to bank pos
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;		        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size		        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - 	        if (i + chunkSize > dataSize) chunkSize = dataSize - 

        // make sure this chunk doesn't go past the bank boun	        // make sure this chunk doesn't go past the bank boun
        if (chunkSize > 256 - address) chunkSize = 256 - addr	        if (chunkSize > 256 - address) chunkSize = 256 - addr
							      |	        
        if (useProgMem) {					        if (useProgMem) {
            // write the chunk of data as specified		            // write the chunk of data as specified
            for (j = 0; j < chunkSize; j++) progBuffer[j] = p	            for (j = 0; j < chunkSize; j++) progBuffer[j] = p
        } else {						        } else {
            // write the chunk of data as specified		            // write the chunk of data as specified
            progBuffer = (uint8_t *)data + i;			            progBuffer = (uint8_t *)data + i;
        }							        }

        I2Cdev_writeBytes(mpu6050.devAddr, MPU6050_RA_MEM_R_W	        I2Cdev_writeBytes(mpu6050.devAddr, MPU6050_RA_MEM_R_W

        // verify data if needed				        // verify data if needed
        if (verify && verifyBuffer) {				        if (verify && verifyBuffer) {
            MPU6050_setMemoryBank(bank, false, false);		            MPU6050_setMemoryBank(bank, false, false);
            MPU6050_setMemoryStartAddress(address);		            MPU6050_setMemoryStartAddress(address);
            I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_MEM_	            I2Cdev_readBytes(mpu6050.devAddr, MPU6050_RA_MEM_
            if (memcmp(progBuffer, verifyBuffer, chunkSize) !	            if (memcmp(progBuffer, verifyBuffer, chunkSize) !
                //Serial.print("Block write verification erro	                //Serial.print("Block write verification erro
                //Serial.print(bank, DEC);			                //Serial.print(bank, DEC);
                //Serial.print(", address ");			                //Serial.print(", address ");
                //Serial.print(address, DEC);			                //Serial.print(address, DEC);
                //Serial.print("!\nExpected:");			                //Serial.print("!\nExpected:");
                //for (j = 0; j < chunkSize; j++) {		                //for (j = 0; j < chunkSize; j++) {
                //    Serial.print(" 0x");			                //    Serial.print(" 0x");
                //    if (progBuffer[j] < 16) Serial.print("0	                //    if (progBuffer[j] < 16) Serial.print("0
                //    Serial.print(progBuffer[j], HEX);		                //    Serial.print(progBuffer[j], HEX);
                //}						                //}
                //Serial.print("\nReceived:");			                //Serial.print("\nReceived:");
                //for (uint8_t j = 0; j < chunkSize; j++) {	                //for (uint8_t j = 0; j < chunkSize; j++) {
                //    Serial.print(" 0x");			                //    Serial.print(" 0x");
                //    if (verifyBuffer[i + j] < 16) Serial.pr	                //    if (verifyBuffer[i + j] < 16) Serial.pr
                //    Serial.print(verifyBuffer[i + j], HEX);	                //    Serial.print(verifyBuffer[i + j], HEX);
                //}						                //}
                Serial.print("\n");				                Serial.print("\n");
                free(verifyBuffer);				                free(verifyBuffer);
                if (useProgMem) free(progBuffer);		                if (useProgMem) free(progBuffer);
                return false; // uh oh.				                return false; // uh oh.
            }							            }
        }							        }

        // increase byte index by [chunkSize]			        // increase byte index by [chunkSize]
        i += chunkSize;						        i += chunkSize;

        // uint8_t automatically wraps to 0 at 256		        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;					        address += chunkSize;

        // if we aren't done, update bank (if necessary) and 	        // if we aren't done, update bank (if necessary) and 
        if (i < dataSize) {					        if (i < dataSize) {
            if (address == 0) bank++;				            if (address == 0) bank++;
            MPU6050_setMemoryBank(bank, false, false);		            MPU6050_setMemoryBank(bank, false, false);
            MPU6050_setMemoryStartAddress(address);		            MPU6050_setMemoryStartAddress(address);
        }							        }
    }								    }
    if (verify) free(verifyBuffer);				    if (verify) free(verifyBuffer);
    if (useProgMem) free(progBuffer);				    if (useProgMem) free(progBuffer);
    return true;						    return true;
}								}
bool MPU6050_writeProgMemoryBlock(const uint8_t *data, uint16	bool MPU6050_writeProgMemoryBlock(const uint8_t *data, uint16
    return MPU6050_writeMemoryBlock(data, dataSize, bank, add	    return MPU6050_writeMemoryBlock(data, dataSize, bank, add
}								}
bool MPU6050_writeDMPConfigurationSet(const uint8_t *data, ui	bool MPU6050_writeDMPConfigurationSet(const uint8_t *data, ui
    uint8_t *progBuffer, success, special;			    uint8_t *progBuffer, success, special;
    uint16_t i, j;						    uint16_t i, j;
    if (useProgMem) {						    if (useProgMem) {
        progBuffer = (uint8_t *)malloc(8); // assume 8-byte b	        progBuffer = (uint8_t *)malloc(8); // assume 8-byte b
    }								    }

    // config set data is a long string of blocks with the fo	    // config set data is a long string of blocks with the fo
    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[	    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[
    uint8_t bank, offset, length;				    uint8_t bank, offset, length;
    for (i = 0; i < dataSize;) {				    for (i = 0; i < dataSize;) {
        if (useProgMem) {					        if (useProgMem) {
            bank = pgm_read_byte(data + i++);			            bank = pgm_read_byte(data + i++);
            offset = pgm_read_byte(data + i++);			            offset = pgm_read_byte(data + i++);
            length = pgm_read_byte(data + i++);			            length = pgm_read_byte(data + i++);
        } else {						        } else {
            bank = data[i++];					            bank = data[i++];
            offset = data[i++];					            offset = data[i++];
            length = data[i++];					            length = data[i++];
        }							        }

        // write data or perform special action			        // write data or perform special action
        if (length > 0) {					        if (length > 0) {
            // regular block of data to write			            // regular block of data to write
            //Serial.print("Writing config block to bank ");	            //Serial.print("Writing config block to bank ");
            //Serial.print(bank);				            //Serial.print(bank);
            //Serial.print(", offset ");			            //Serial.print(", offset ");
            //Serial.print(offset);				            //Serial.print(offset);
            //Serial.print(", length=");			            //Serial.print(", length=");
            //Serial.println(length);				            //Serial.println(length);
            if (useProgMem) {					            if (useProgMem) {
                if (sizeof(progBuffer) < length) progBuffer =	                if (sizeof(progBuffer) < length) progBuffer =
                for (j = 0; j < length; j++) progBuffer[j] = 	                for (j = 0; j < length; j++) progBuffer[j] = 
            } else {						            } else {
                progBuffer = (uint8_t *)data + i;		                progBuffer = (uint8_t *)data + i;
            }							            }
            success = MPU6050_writeMemoryBlock(progBuffer, le	            success = MPU6050_writeMemoryBlock(progBuffer, le
            i += length;					            i += length;
        } else {						        } else {
            // special instruction				            // special instruction
            // NOTE: this kind of behavior (what and when to 	            // NOTE: this kind of behavior (what and when to 
            // is totally undocumented. This code is in here 	            // is totally undocumented. This code is in here 
            // behavior only, and exactly why (or even whethe	            // behavior only, and exactly why (or even whethe
            // is anybody's guess for now.			            // is anybody's guess for now.
            if (useProgMem) {					            if (useProgMem) {
                special = pgm_read_byte(data + i++);		                special = pgm_read_byte(data + i++);
            } else {						            } else {
                special = data[i++];				                special = data[i++];
            }							            }
            //Serial.print("Special command code ");		            //Serial.print("Special command code ");
            //Serial.print(special, HEX);			            //Serial.print(special, HEX);
            //Serial.println(" found...");			            //Serial.println(" found...");
            if (special == 0x01) {				            if (special == 0x01) {
                // enable DMP-related interrupts		                // enable DMP-related interrupts
							      |	                
                //setIntZeroMotionEnabled(true);		                //setIntZeroMotionEnabled(true);
                //setIntFIFOBufferOverflowEnabled(true);	                //setIntFIFOBufferOverflowEnabled(true);
                //setIntDMPEnabled(true);			                //setIntDMPEnabled(true);
                I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_	                I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_

                success = true;					                success = true;
            } else {						            } else {
                // unknown special command			                // unknown special command
                success = false;				                success = false;
            }							            }
        }							        }
							      |	        
        if (!success) {						        if (!success) {
            if (useProgMem) free(progBuffer);			            if (useProgMem) free(progBuffer);
            return false; // uh oh				            return false; // uh oh
        }							        }
    }								    }
    if (useProgMem) free(progBuffer);				    if (useProgMem) free(progBuffer);
    return true;						    return true;
}								}
bool MPU6050_writeProgDMPConfigurationSet(const uint8_t *data	bool MPU6050_writeProgDMPConfigurationSet(const uint8_t *data
    return MPU6050_writeDMPConfigurationSet(data, dataSize, t	    return MPU6050_writeDMPConfigurationSet(data, dataSize, t
}*/								}*/

// DMP_CFG_1 register						// DMP_CFG_1 register

uint8_t MPU6050_getDMPConfig1()				      |	uint8_t MPU6050_getDMPConfig1() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_1, mp
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_1 |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      |	}
}							      |	void MPU6050_setDMPConfig1(uint8_t config) {
void MPU6050_setDMPConfig1(uint8_t config)		      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_1, c
{							      <
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_ <
}								}

// DMP_CFG_2 register						// DMP_CFG_2 register

uint8_t MPU6050_getDMPConfig2()				      |	uint8_t MPU6050_getDMPConfig2() {
{							      |	    I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_2, mp
	I2Cdev_readByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_2 |	    return mpu6050.buffer[0];
	return mpu6050.buffer[0];			      |	}
}							      |	void MPU6050_setDMPConfig2(uint8_t config) {
void MPU6050_setDMPConfig2(uint8_t config)		      |	    I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_2, c
{							      <
	I2Cdev_writeByte(mpu6050.devAddr, MPU6050_RA_DMP_CFG_ <
}								}
